require "pandarus/api_base"
require "pandarus/models"

# This is an autogenerated file. See readme.md.
module Pandarus
  class V1_api < APIBase

    self.prefix = "http://canvas.instructure.com/api"

    def list_authorization_configs(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/account_authorization_configs",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|AccountAuthorizationConfig.new(response)}
    end
    def create_authorization_config(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/account_authorization_configs",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      AccountAuthorizationConfig.new(response)
    end
    def update_authorization_config(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/account_authorization_configs/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      AccountAuthorizationConfig.new(response)
    end
    def get_authorization_config(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/account_authorization_configs/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      AccountAuthorizationConfig.new(response)
    end
    def delete_authorization_config(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/account_authorization_configs/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def get_discovery_url(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/account_authorization_configs/discovery_url",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      DiscoveryUrl.new(response)
    end
    def set_discovery_url(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/account_authorization_configs/discovery_url",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      DiscoveryUrl.new(response)
    end
    def delete_discovery_url(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/account_authorization_configs/discovery_url",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def list_available_reports(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/reports",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def start_report(account_id,report,__parameters__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :__parameters__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "report is required" if report.nil?
      raise "__parameters__ is required" if __parameters__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :report => report,
        :__parameters__ => __parameters__
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/reports/{report}",
        :account_id => account_id,
        :report => report)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      report.new(response)
    end
    def index_of_reports(account_id,report,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "report is required" if report.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :report => report
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/reports/{report}",
        :account_id => account_id,
        :report => report)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Report.new(response)}
    end
    def status_of_report(account_id,report,id,report_id,opts={})
      query_param_keys = [
        :report_id
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "report is required" if report.nil?
      raise "id is required" if id.nil?
      raise "report_id is required" if report_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :report => report,
        :id => id,
        :report_id => report_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/reports/{report}/{id}",
        :account_id => account_id,
        :report => report,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      Report.new(response)
    end
    def delete_report(account_id,report,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "report is required" if report.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :report => report,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/reports/{report}/{id}",
        :account_id => account_id,
        :report => report,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      Report.new(response)
    end
    def list_accounts(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/accounts",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_single_account(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_the_sub_accounts_of_account(account_id,opts={})
      query_param_keys = [
        :recursive
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/sub_accounts",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_active_courses_in_account(account_id,opts={})
      query_param_keys = [
        :with_enrollments,
        :published,
        :completed,
        :by_teachers,
        :by_subaccounts,
        :hide_enrollmentless_courses,
        :state,
        :enrollment_term_id
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/courses",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Course.new(response)}
    end
    def update_account(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :account__name__,
        :account__default_time_zone__,
        :account__default_storage_quota_mb__,
        :account__default_user_storage_quota_mb__,
        :account__default_group_storage_quota_mb__,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def change_the_domains_for_account(id,account__domains__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :account__domains__,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "account__domains__ is required" if account__domains__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :account__domains__ => account__domains__
      )

      # resource path
      path = path_replace("/v1/accounts/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def get_single_account_internal(id,opts={})
      query_param_keys = [
        :includes
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def create_new_root_account(account__name__,account__domain__,account__settings__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :account__name__,
        :account__domain__,
        :account__services__,
        :account__settings__,
        
      ]

      # verify existence of params
      raise "account__name__ is required" if account__name__.nil?
      raise "account__domain__ is required" if account__domain__.nil?
      raise "account__settings__ is required" if account__settings__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account__name__ => account__name__,
        :account__domain__ => account__domain__,
        :account__settings__ => account__settings__
      )

      # resource path
      path = path_replace("/v1/accounts",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def create_new_sub_account(account_id,account__name__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :account__name__,
        :account__default_storage_quota_mb__,
        :account__default_user_storage_quota_mb__,
        :account__default_group_storage_quota_mb__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "account__name__ is required" if account__name__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :account__name__ => account__name__
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/sub_accounts",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response.map {|response|Account.new(response)}
    end
    def make_account_admin(account_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :user_id,
        :role,
        :send_confirmation,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/admins",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Admin.new(response)
    end
    def remove_account_admin(account_id,user_id,opts={})
      query_param_keys = [
        :role
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/admins/{user_id}",
        :account_id => account_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      Admin.new(response)
    end
    def list_account_admins(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/admins",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Admin.new(response)}
    end
    def get_department_level_participation_data_accounts(account_id,term_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "term_id is required" if term_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :term_id => term_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/analytics/terms/{term_id}/activity",
        :account_id => account_id,
        :term_id => term_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_department_level_participation_data_accounts(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/analytics/current/activity",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_department_level_participation_data_accounts(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/analytics/completed/activity",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_department_level_grade_data_accounts(account_id,term_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "term_id is required" if term_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :term_id => term_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/analytics/terms/{term_id}/grades",
        :account_id => account_id,
        :term_id => term_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_department_level_grade_data_accounts(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/analytics/current/grades",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_department_level_grade_data_accounts(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/analytics/completed/grades",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_department_level_statistics_accounts(account_id,term_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "term_id is required" if term_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :term_id => term_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/analytics/terms/{term_id}/statistics",
        :account_id => account_id,
        :term_id => term_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_department_level_statistics_accounts(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/analytics/current/statistics",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_department_level_statistics_accounts(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/analytics/completed/statistics",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_course_level_participation_data(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/analytics/activity",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_course_level_assignment_data(course_id,async,opts={})
      query_param_keys = [
        :async
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "async is required" if async.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :async => async
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/analytics/assignments",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_course_level_student_summary_data(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/analytics/student_summaries",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_user_in_a_course_level_participation_data(course_id,student_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "student_id is required" if student_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :student_id => student_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/analytics/users/{student_id}/activity",
        :course_id => course_id,
        :student_id => student_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_user_in_a_course_level_assignment_data(course_id,student_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "student_id is required" if student_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :student_id => student_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/analytics/users/{student_id}/assignments",
        :course_id => course_id,
        :student_id => student_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_user_in_a_course_level_messaging_data(course_id,student_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "student_id is required" if student_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :student_id => student_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/analytics/users/{student_id}/communication",
        :course_id => course_id,
        :student_id => student_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_external_feeds_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/external_feeds",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|ExternalFeed.new(response)}
    end
    def list_external_feeds_groups(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/external_feeds",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|ExternalFeed.new(response)}
    end
    def create_external_feed_courses(course_id,url,verbosity,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :url,
        :header_match,
        :verbosity,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "url is required" if url.nil?
      raise "verbosity is required" if verbosity.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :url => url,
        :verbosity => verbosity
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/external_feeds",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      ExternalFeed.new(response)
    end
    def create_external_feed_groups(group_id,url,verbosity,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :url,
        :header_match,
        :verbosity,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "url is required" if url.nil?
      raise "verbosity is required" if verbosity.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :url => url,
        :verbosity => verbosity
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/external_feeds",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      ExternalFeed.new(response)
    end
    def delete_external_feed_courses(course_id,external_feed_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "external_feed_id is required" if external_feed_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :external_feed_id => external_feed_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/external_feeds/{external_feed_id}",
        :course_id => course_id,
        :external_feed_id => external_feed_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      ExternalFeed.new(response)
    end
    def delete_external_feed_groups(group_id,external_feed_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "external_feed_id is required" if external_feed_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :external_feed_id => external_feed_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/external_feeds/{external_feed_id}",
        :group_id => group_id,
        :external_feed_id => external_feed_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      ExternalFeed.new(response)
    end
    def list_appointment_groups(opts={})
      query_param_keys = [
        :scope,
        :context_codes,
        :include_past_appointments,
        :include
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/appointment_groups",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def create_appointment_group(appointment_group__context_codes__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :appointment_group__context_codes__,
        :appointment_group__sub_context_codes__,
        :appointment_group__title__,
        :appointment_group__description__,
        :appointment_group__location_name__,
        :appointment_group__location_address__,
        :appointment_group__publish__,
        :appointment_group__participants_per_appointment__,
        :appointment_group__min_appointments_per_participant__,
        :appointment_group__max_appointments_per_participant__,
        :appointment_group__new_appointments_____x__,
        :appointment_group__participant_visibility__,
        
      ]

      # verify existence of params
      raise "appointment_group__context_codes__ is required" if appointment_group__context_codes__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :appointment_group__context_codes__ => appointment_group__context_codes__
      )

      # resource path
      path = path_replace("/v1/appointment_groups",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def get_single_appointment_group(id,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/appointment_groups/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def update_appointment_group(id,appointment_group__context_codes__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :appointment_group__context_codes__,
        :appointment_group__sub_context_codes__,
        :appointment_group__title__,
        :appointment_group__description__,
        :appointment_group__location_name__,
        :appointment_group__location_address__,
        :appointment_group__publish__,
        :appointment_group__participants_per_appointment__,
        :appointment_group__min_appointments_per_participant__,
        :appointment_group__max_appointments_per_participant__,
        :appointment_group__new_appointments_____x__,
        :appointment_group__participant_visibility__,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "appointment_group__context_codes__ is required" if appointment_group__context_codes__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :appointment_group__context_codes__ => appointment_group__context_codes__
      )

      # resource path
      path = path_replace("/v1/appointment_groups/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def delete_appointment_group(id,opts={})
      query_param_keys = [
        :cancel_reason
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/appointment_groups/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def list_user_participants(id,opts={})
      query_param_keys = [
        :registration_status
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/appointment_groups/{id}/users",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_student_group_participants(id,opts={})
      query_param_keys = [
        :registration_status
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/appointment_groups/{id}/groups",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_assignment_groups(course_id,include,opts={})
      query_param_keys = [
        :include,
        :override_assignment_dates
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :include => include
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignment_groups",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|AssignmentGroup.new(response)}
    end
    def get_assignment_group(course_id,assignment_group_id,include,opts={})
      query_param_keys = [
        :include,
        :override_assignment_dates
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_group_id is required" if assignment_group_id.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_group_id => assignment_group_id,
        :include => include
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignment_groups/{assignment_group_id}",
        :course_id => course_id,
        :assignment_group_id => assignment_group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      AssignmentGroup.new(response)
    end
    def create_assignment_group(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :position,
        :group_weight,
        :rules,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignment_groups",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      AssignmentGroup.new(response)
    end
    def edit_assignment_group(course_id,assignment_group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_group_id is required" if assignment_group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_group_id => assignment_group_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignment_groups/{assignment_group_id}",
        :course_id => course_id,
        :assignment_group_id => assignment_group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      AssignmentGroup.new(response)
    end
    def destroy_assignment_group(course_id,assignment_group_id,move_assignment_to,opts={})
      query_param_keys = [
        :move_assignment_to
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_group_id is required" if assignment_group_id.nil?
      raise "move_assignment_to is required" if move_assignment_to.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_group_id => assignment_group_id,
        :move_assignment_to => move_assignment_to
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignment_groups/{assignment_group_id}",
        :course_id => course_id,
        :assignment_group_id => assignment_group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      AssignmentGroup.new(response)
    end
    def delete_assignment(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      Assignment.new(response)
    end
    def list_assignments(course_id,include,opts={})
      query_param_keys = [
        :include,
        :search_term,
        :override_assignment_dates
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :include => include
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Assignment.new(response)}
    end
    def get_single_assignment(course_id,id,include,opts={})
      query_param_keys = [
        :include,
        :override_assignment_dates
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id,
        :include => include
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      Assignment.new(response)
    end
    def create_assignment(course_id,assignment__name__,assignment__position__,assignment__submission_types__,assignment__allowed_extensions__,assignment__points_possible__,assignment__due_at__,assignment__lock_at__,assignment__unlock_at__,assignment__description__,assignment__assignment_group_id__,assignment__muted__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :assignment__name__,
        :assignment__position__,
        :assignment__submission_types__,
        :assignment__allowed_extensions__,
        :assignment__turnitin_enabled__,
        :assignment__turnitin_settings__,
        :assignment__peer_reviews__,
        :assignment__automatic_peer_reviews__,
        :assignment__notify_of_update__,
        :assignment__group_category_id__,
        :assignment__grade_group_students_individually__,
        :assignment__external_tool_tag_attributes__,
        :assignment__points_possible__,
        :assignment__grading_type__,
        :assignment__due_at__,
        :assignment__lock_at__,
        :assignment__unlock_at__,
        :assignment__description__,
        :assignment__assignment_group_id__,
        :assignment__muted__,
        :assignment__assignment_overrides__,
        :assignment__published__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment__name__ is required" if assignment__name__.nil?
      raise "assignment__position__ is required" if assignment__position__.nil?
      raise "assignment__submission_types__ is required" if assignment__submission_types__.nil?
      raise "assignment__allowed_extensions__ is required" if assignment__allowed_extensions__.nil?
      raise "assignment__points_possible__ is required" if assignment__points_possible__.nil?
      raise "assignment__due_at__ is required" if assignment__due_at__.nil?
      raise "assignment__lock_at__ is required" if assignment__lock_at__.nil?
      raise "assignment__unlock_at__ is required" if assignment__unlock_at__.nil?
      raise "assignment__description__ is required" if assignment__description__.nil?
      raise "assignment__assignment_group_id__ is required" if assignment__assignment_group_id__.nil?
      raise "assignment__muted__ is required" if assignment__muted__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment__name__ => assignment__name__,
        :assignment__position__ => assignment__position__,
        :assignment__submission_types__ => assignment__submission_types__,
        :assignment__allowed_extensions__ => assignment__allowed_extensions__,
        :assignment__points_possible__ => assignment__points_possible__,
        :assignment__due_at__ => assignment__due_at__,
        :assignment__lock_at__ => assignment__lock_at__,
        :assignment__unlock_at__ => assignment__unlock_at__,
        :assignment__description__ => assignment__description__,
        :assignment__assignment_group_id__ => assignment__assignment_group_id__,
        :assignment__muted__ => assignment__muted__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Assignment.new(response)
    end
    def edit_assignment(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      Assignment.new(response)
    end
    def list_assignment_overrides(course_id,assignment_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/overrides",
        :course_id => course_id,
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|AssignmentOverride.new(response)}
    end
    def get_single_assignment_override(course_id,assignment_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/overrides/{id}",
        :course_id => course_id,
        :assignment_id => assignment_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      AssignmentOverride.new(response)
    end
    def redirect_to_the_assignment_override_for_group(group_id,assignment_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :assignment_id => assignment_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/assignments/{assignment_id}/override",
        :group_id => group_id,
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def redirect_to_the_assignment_override_for_section(course_section_id,assignment_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_section_id is required" if course_section_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_section_id => course_section_id,
        :assignment_id => assignment_id
      )

      # resource path
      path = path_replace("/v1/sections/{course_section_id}/assignments/{assignment_id}/override",
        :course_section_id => course_section_id,
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def create_assignment_override(course_id,assignment_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :assignment_override__student_ids__,
        :assignment_override__title__,
        :assignment_override__group_id__,
        :assignment_override__course_section_id__,
        :assignment_override__due_at__,
        :assignment_override__unlock_at__,
        :assignment_override__lock_at__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/overrides",
        :course_id => course_id,
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      AssignmentOverride.new(response)
    end
    def update_assignment_override(course_id,assignment_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :assignment_override__student_ids__,
        :assignment_override__title__,
        :assignment_override__due_at__,
        :assignment_override__unlock_at__,
        :assignment_override__lock_at__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/overrides/{id}",
        :course_id => course_id,
        :assignment_id => assignment_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      AssignmentOverride.new(response)
    end
    def delete_assignment_override(course_id,assignment_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/overrides/{id}",
        :course_id => course_id,
        :assignment_id => assignment_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      AssignmentOverride.new(response)
    end
    def query_by_login(login_id,opts={})
      query_param_keys = [
        :start_time,
        :end_time
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "login_id is required" if login_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :login_id => login_id
      )

      # resource path
      path = path_replace("/v1/audit/authentication/logins/{login_id}",
        :login_id => login_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def query_by_account(account_id,opts={})
      query_param_keys = [
        :start_time,
        :end_time
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/audit/authentication/accounts/{account_id}",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def query_by_user(user_id,opts={})
      query_param_keys = [
        :start_time,
        :end_time
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/audit/authentication/users/{user_id}",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_calendar_events(opts={})
      query_param_keys = [
        :type,
        :start_date,
        :end_date,
        :undated,
        :all_events,
        :context_codes
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/calendar_events",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def create_calendar_event(calendar_event__context_code__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :calendar_event__context_code__,
        :calendar_event__title__,
        :calendar_event__description__,
        :calendar_event__start_at__,
        :calendar_event__end_at__,
        :calendar_event__location_name__,
        :calendar_event__location_address__,
        :calendar_event__time_zone_edited__,
        :calendar_event__child_event_data_____x____start_at__,
        :calendar_event__child_event_data_____x____end_at__,
        :calendar_event__child_event_data_____x____context_code__,
        
      ]

      # verify existence of params
      raise "calendar_event__context_code__ is required" if calendar_event__context_code__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :calendar_event__context_code__ => calendar_event__context_code__
      )

      # resource path
      path = path_replace("/v1/calendar_events",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def get_single_calendar_event_or_assignment(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/calendar_events/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def reserve_time_slot_calendar_events(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :participant_id,
        :cancel_existing,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/calendar_events/{id}/reservations",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def reserve_time_slot_calendar_events(id,participant_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :cancel_existing,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "participant_id is required" if participant_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :participant_id => participant_id
      )

      # resource path
      path = path_replace("/v1/calendar_events/{id}/reservations/{participant_id}",
        :id => id,
        :participant_id => participant_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def update_calendar_event(id,calendar_event__context_code__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :calendar_event__context_code__,
        :calendar_event__title__,
        :calendar_event__description__,
        :calendar_event__start_at__,
        :calendar_event__end_at__,
        :calendar_event__location_name__,
        :calendar_event__location_address__,
        :calendar_event__time_zone_edited__,
        :calendar_event__child_event_data_____x____start_at__,
        :calendar_event__child_event_data_____x____end_at__,
        :calendar_event__child_event_data_____x____context_code__,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "calendar_event__context_code__ is required" if calendar_event__context_code__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :calendar_event__context_code__ => calendar_event__context_code__
      )

      # resource path
      path = path_replace("/v1/calendar_events/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def delete_calendar_event(id,opts={})
      query_param_keys = [
        :cancel_reason
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/calendar_events/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def list_members_of_collaboration(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/collaborations/{id}/members",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Collaborator.new(response)}
    end
    def list_user_group_collections_users(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/collections",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Collection.new(response)}
    end
    def list_user_group_collections_groups(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/collections",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Collection.new(response)}
    end
    def list_pinnable_collections(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/collections",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_single_collection(collection_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "collection_id is required" if collection_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_id => collection_id
      )

      # resource path
      path = path_replace("/v1/collections/{collection_id}",
        :collection_id => collection_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      Collection.new(response)
    end
    def create_collection_users(user_id,name,visibility,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :visibility,
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "name is required" if name.nil?
      raise "visibility is required" if visibility.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :name => name,
        :visibility => visibility
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/collections",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Collection.new(response)
    end
    def create_collection_groups(group_id,name,visibility,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :visibility,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "name is required" if name.nil?
      raise "visibility is required" if visibility.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :name => name,
        :visibility => visibility
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/collections",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Collection.new(response)
    end
    def edit_collection(collection_id,name,visibility,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :visibility,
        
      ]

      # verify existence of params
      raise "collection_id is required" if collection_id.nil?
      raise "name is required" if name.nil?
      raise "visibility is required" if visibility.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_id => collection_id,
        :name => name,
        :visibility => visibility
      )

      # resource path
      path = path_replace("/v1/collections/{collection_id}",
        :collection_id => collection_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      Collection.new(response)
    end
    def delete_collection(collection_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "collection_id is required" if collection_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_id => collection_id
      )

      # resource path
      path = path_replace("/v1/collections/{collection_id}",
        :collection_id => collection_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      Collection.new(response)
    end
    def follow_collection(collection_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "collection_id is required" if collection_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_id => collection_id
      )

      # resource path
      path = path_replace("/v1/collections/{collection_id}/followers/self",
        :collection_id => collection_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def un_follow_collection(collection_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "collection_id is required" if collection_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_id => collection_id
      )

      # resource path
      path = path_replace("/v1/collections/{collection_id}/followers/self",
        :collection_id => collection_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def list_collection_items_collections(collection_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "collection_id is required" if collection_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_id => collection_id
      )

      # resource path
      path = path_replace("/v1/collections/{collection_id}/items",
        :collection_id => collection_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|CollectionItem.new(response)}
    end
    def list_collection_items_collections(collection_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "collection_id is required" if collection_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_id => collection_id
      )

      # resource path
      path = path_replace("/v1/collections/{collection_id}/items",
        :collection_id => collection_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|CollectionItem.new(response)}
    end
    def get_individual_collection_item(item_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "item_id is required" if item_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :item_id => item_id
      )

      # resource path
      path = path_replace("/v1/collections/items/{item_id}",
        :item_id => item_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      CollectionItem.new(response)
    end
    def create_or_clone_collection_item(collection_id,link_url,title,description,image_url,user_comment,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :link_url,
        :title,
        :description,
        :image_url,
        :user_comment,
        
      ]

      # verify existence of params
      raise "collection_id is required" if collection_id.nil?
      raise "link_url is required" if link_url.nil?
      raise "title is required" if title.nil?
      raise "description is required" if description.nil?
      raise "image_url is required" if image_url.nil?
      raise "user_comment is required" if user_comment.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_id => collection_id,
        :link_url => link_url,
        :title => title,
        :description => description,
        :image_url => image_url,
        :user_comment => user_comment
      )

      # resource path
      path = path_replace("/v1/collections/{collection_id}/items",
        :collection_id => collection_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      CollectionItem.new(response)
    end
    def edit_collection_item(item_id,user_comment,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :user_comment,
        
      ]

      # verify existence of params
      raise "item_id is required" if item_id.nil?
      raise "user_comment is required" if user_comment.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :item_id => item_id,
        :user_comment => user_comment
      )

      # resource path
      path = path_replace("/v1/collections/items/{item_id}",
        :item_id => item_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      CollectionItem.new(response)
    end
    def delete_collection_item(item_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "item_id is required" if item_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :item_id => item_id
      )

      # resource path
      path = path_replace("/v1/collections/items/{item_id}",
        :item_id => item_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      CollectionItem.new(response)
    end
    def upvote_item(item_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "item_id is required" if item_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :item_id => item_id
      )

      # resource path
      path = path_replace("/v1/collections/items/{item_id}/upvotes/self",
        :item_id => item_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def de_upvote_item(item_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "item_id is required" if item_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :item_id => item_id
      )

      # resource path
      path = path_replace("/v1/collections/items/{item_id}/upvotes/self",
        :item_id => item_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def list_of_commmessages_for_user(user_id,opts={})
      query_param_keys = [
        :user_id,
        :start_time,
        :end_time
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/comm_messages",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|CommMessage.new(response)}
    end
    def list_user_communication_channels(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/communication_channels",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|CommunicationChannel.new(response)}
    end
    def create_communication_channel(user_id,communication_channel__address__,communication_channel__type__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :communication_channel__address__,
        :communication_channel__type__,
        :skip_confirmation,
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "communication_channel__address__ is required" if communication_channel__address__.nil?
      raise "communication_channel__type__ is required" if communication_channel__type__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :communication_channel__address__ => communication_channel__address__,
        :communication_channel__type__ => communication_channel__type__
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/communication_channels",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      CommunicationChannel.new(response)
    end
    def delete_communication_channel_users(user_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/communication_channels/{id}",
        :user_id => user_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      CommunicationChannel.new(response)
    end
    def delete_communication_channel_users(user_id,type,address,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "type is required" if type.nil?
      raise "address is required" if address.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :type => type,
        :address => address
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/communication_channels/{type}/{address}",
        :user_id => user_id,
        :type => type,
        :address => address)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      CommunicationChannel.new(response)
    end
    def list_conferences_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/conferences",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Conference.new(response)}
    end
    def list_conferences_groups(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/conferences",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Conference.new(response)}
    end
    def list_content_exports(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_exports",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|ContentExport.new(response)}
    end
    def show_content_export(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_exports/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      ContentExport.new(response)
    end
    def export_course_content(course_id,export_type,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :export_type,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "export_type is required" if export_type.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :export_type => export_type
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_exports",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      ContentExport.new(response)
    end
    def list_migration_issues(course_id,content_migration_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "content_migration_id is required" if content_migration_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :content_migration_id => content_migration_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_migrations/{content_migration_id}/migration_issues",
        :course_id => course_id,
        :content_migration_id => content_migration_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|MigrationIssue.new(response)}
    end
    def get_migration_issue(course_id,content_migration_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "content_migration_id is required" if content_migration_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :content_migration_id => content_migration_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_migrations/{content_migration_id}/migration_issues/{id}",
        :course_id => course_id,
        :content_migration_id => content_migration_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      MigrationIssue.new(response)
    end
    def update_migration_issue(course_id,content_migration_id,id,workflow_state,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :workflow_state,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "content_migration_id is required" if content_migration_id.nil?
      raise "id is required" if id.nil?
      raise "workflow_state is required" if workflow_state.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :content_migration_id => content_migration_id,
        :id => id,
        :workflow_state => workflow_state
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_migrations/{content_migration_id}/migration_issues/{id}",
        :course_id => course_id,
        :content_migration_id => content_migration_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      MigrationIssue.new(response)
    end
    def list_content_migrations(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_migrations",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|ContentMigration.new(response)}
    end
    def get_content_migration(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_migrations/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      ContentMigration.new(response)
    end
    def create_content_migration(course_id,migration_type,pre_attachment__name__,settings__file_url__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :migration_type,
        :pre_attachment__name__,
        :pre_attachment__x__,
        :settings__file_url__,
        :settings__source_course_id__,
        :settings__folder_id__,
        :settings__overwrite_quizzes__,
        :settings__question_bank_id__,
        :settings__question_bank_name__,
        :date_shift_options__shift_dates__,
        :date_shift_options__old_start_date__,
        :date_shift_options__old_end_date__,
        :date_shift_options__new_start_date__,
        :date_shift_options__new_end_date__,
        :date_shift_options__day_substitutions_____x__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "migration_type is required" if migration_type.nil?
      raise "pre_attachment__name__ is required" if pre_attachment__name__.nil?
      raise "settings__file_url__ is required" if settings__file_url__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :migration_type => migration_type,
        :pre_attachment__name__ => pre_attachment__name__,
        :settings__file_url__ => settings__file_url__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_migrations",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      ContentMigration.new(response)
    end
    def update_content_migration(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_migrations/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      ContentMigration.new(response)
    end
    def list_migration_systems(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_migrations/migrators",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Migrator.new(response)}
    end
    def list_conversations(interleave_submissions,include_all_conversation_ids,opts={})
      query_param_keys = [
        :scope,
        :filter,
        :filter_mode,
        :interleave_submissions,
        :include_all_conversation_ids
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "interleave_submissions is required" if interleave_submissions.nil?
      raise "include_all_conversation_ids is required" if include_all_conversation_ids.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :interleave_submissions => interleave_submissions,
        :include_all_conversation_ids => include_all_conversation_ids
      )

      # resource path
      path = path_replace("/v1/conversations",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def create_conversation(recipients,body,group_conversation,attachment_ids,media_comment_id,media_comment_type,mode,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :recipients,
        :subject,
        :body,
        :group_conversation,
        :attachment_ids,
        :media_comment_id,
        :media_comment_type,
        :mode,
        :scope,
        :filter,
        :filter_mode,
        :context_code,
        
      ]

      # verify existence of params
      raise "recipients is required" if recipients.nil?
      raise "body is required" if body.nil?
      raise "group_conversation is required" if group_conversation.nil?
      raise "attachment_ids is required" if attachment_ids.nil?
      raise "media_comment_id is required" if media_comment_id.nil?
      raise "media_comment_type is required" if media_comment_type.nil?
      raise "mode is required" if mode.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :recipients => recipients,
        :body => body,
        :group_conversation => group_conversation,
        :attachment_ids => attachment_ids,
        :media_comment_id => media_comment_id,
        :media_comment_type => media_comment_type,
        :mode => mode
      )

      # resource path
      path = path_replace("/v1/conversations",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def x(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/conversations/batches",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_single_conversation(id,interleave_submissions,auto_mark_as_read,opts={})
      query_param_keys = [
        :interleave_submissions,
        :scope,
        :filter,
        :filter_mode,
        :auto_mark_as_read
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "interleave_submissions is required" if interleave_submissions.nil?
      raise "auto_mark_as_read is required" if auto_mark_as_read.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :interleave_submissions => interleave_submissions,
        :auto_mark_as_read => auto_mark_as_read
      )

      # resource path
      path = path_replace("/v1/conversations/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def edit_conversation(id,conversation__subject__,conversation__workflow_state__,conversation__subscribed__,conversation__starred__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :conversation__subject__,
        :conversation__workflow_state__,
        :conversation__subscribed__,
        :conversation__starred__,
        :scope,
        :filter,
        :filter_mode,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "conversation__subject__ is required" if conversation__subject__.nil?
      raise "conversation__workflow_state__ is required" if conversation__workflow_state__.nil?
      raise "conversation__subscribed__ is required" if conversation__subscribed__.nil?
      raise "conversation__starred__ is required" if conversation__starred__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :conversation__subject__ => conversation__subject__,
        :conversation__workflow_state__ => conversation__workflow_state__,
        :conversation__subscribed__ => conversation__subscribed__,
        :conversation__starred__ => conversation__starred__
      )

      # resource path
      path = path_replace("/v1/conversations/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def mark_all_as_read(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/conversations/mark_all_as_read",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def delete_conversation(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/conversations/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def add_recipients(id,recipients,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :recipients,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "recipients is required" if recipients.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :recipients => recipients
      )

      # resource path
      path = path_replace("/v1/conversations/{id}/add_recipients",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def add_message(id,body,attachment_ids,media_comment_id,media_comment_type,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :body,
        :attachment_ids,
        :media_comment_id,
        :media_comment_type,
        :recipients,
        :included_messages,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "body is required" if body.nil?
      raise "attachment_ids is required" if attachment_ids.nil?
      raise "media_comment_id is required" if media_comment_id.nil?
      raise "media_comment_type is required" if media_comment_type.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :body => body,
        :attachment_ids => attachment_ids,
        :media_comment_id => media_comment_id,
        :media_comment_type => media_comment_type
      )

      # resource path
      path = path_replace("/v1/conversations/{id}/add_message",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def delete_message(id,remove,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :remove,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "remove is required" if remove.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :remove => remove
      )

      # resource path
      path = path_replace("/v1/conversations/{id}/remove_messages",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def batch_update_conversations(conversation_ids,event,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :conversation_ids,
        :event,
        
      ]

      # verify existence of params
      raise "conversation_ids is required" if conversation_ids.nil?
      raise "event is required" if event.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :conversation_ids => conversation_ids,
        :event => event
      )

      # resource path
      path = path_replace("/v1/conversations",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      Progress.new(response)
    end
    def find_recipients(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/conversations/find_recipients",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def unread_count(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/conversations/unread_count",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_your_courses(include,opts={})
      query_param_keys = [
        :enrollment_type,
        :enrollment_role,
        :include,
        :state
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :include => include
      )

      # resource path
      path = path_replace("/v1/courses",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Course.new(response)}
    end
    def create_new_course(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :course__name__,
        :course__course_code__,
        :course__start_at__,
        :course__end_at__,
        :course__license__,
        :course__is_public__,
        :course__public_syllabus__,
        :course__public_description__,
        :course__allow_student_wiki_edits__,
        :course__allow_wiki_comments__,
        :course__allow_student_forum_attachments__,
        :course__open_enrollment__,
        :course__self_enrollment__,
        :course__restrict_enrollments_to_course_dates__,
        :course__enroll_me__,
        :course__sis_course_id__,
        :course__hide_final_grades__,
        :course__apply_assignment_group_weights__,
        :offer,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/courses",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Course.new(response)
    end
    def upload_file(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/files",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def list_students(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/students",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|User.new(response)}
    end
    def list_users_in_course_courses(course_id,include,opts={})
      query_param_keys = [
        :search_term,
        :enrollment_type,
        :enrollment_role,
        :include,
        :user_id
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :include => include
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/users",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|User.new(response)}
    end
    def list_users_in_course_courses(course_id,include,opts={})
      query_param_keys = [
        :search_term,
        :enrollment_type,
        :enrollment_role,
        :include,
        :user_id
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :include => include
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/search_users",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|User.new(response)}
    end
    def list_recently_logged_in_students(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/recent_students",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|User.new(response)}
    end
    def x(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/users/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      User.new(response)
    end
    def preview_processed_html(course_id,html,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :html,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "html is required" if html.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :html => html
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/preview_html",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def course_activity_stream(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/activity_stream",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def course_activity_stream_summary(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/activity_stream/summary",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def course_todo_items(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/todo",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def conclude_course(id,event,opts={})
      query_param_keys = [
        :event
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "event is required" if event.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :event => event
      )

      # resource path
      path = path_replace("/v1/courses/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def get_course_settings(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/settings",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def update_course_settings(course_id,allow_student_discussion_topics,allow_student_forum_attachments,allow_student_discussion_editing,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :allow_student_discussion_topics,
        :allow_student_forum_attachments,
        :allow_student_discussion_editing,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "allow_student_discussion_topics is required" if allow_student_discussion_topics.nil?
      raise "allow_student_forum_attachments is required" if allow_student_forum_attachments.nil?
      raise "allow_student_discussion_editing is required" if allow_student_discussion_editing.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :allow_student_discussion_topics => allow_student_discussion_topics,
        :allow_student_forum_attachments => allow_student_forum_attachments,
        :allow_student_discussion_editing => allow_student_discussion_editing
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/settings",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def get_single_course_courses(id,include,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :include => include
      )

      # resource path
      path = path_replace("/v1/courses/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      Course.new(response)
    end
    def get_single_course_accounts(account_id,id,include,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id,
        :include => include
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/courses/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      Course.new(response)
    end
    def update_course(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def update_courses(account_id,course_ids,event,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :course_ids,
        :event,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "course_ids is required" if course_ids.nil?
      raise "event is required" if event.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :course_ids => course_ids,
        :event => event
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/courses",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      Progress.new(response)
    end
    def get_course_copy_status(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/course_copy/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def copy_course_content(course_id,source_course,except,only,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :source_course,
        :except,
        :only,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "source_course is required" if source_course.nil?
      raise "except is required" if except.nil?
      raise "only is required" if only.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :source_course => source_course,
        :except => except,
        :only => only
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/course_copy",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def list_custom_gradebook_columns(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/custom_gradebook_columns",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|CustomColumn.new(response)}
    end
    def create_custom_gradebook_column(course_id,column__title__,column__position__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :column__title__,
        :column__position__,
        :column__hidden__,
        :column__teacher_notes__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "column__title__ is required" if column__title__.nil?
      raise "column__position__ is required" if column__position__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :column__title__ => column__title__,
        :column__position__ => column__position__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/custom_gradebook_columns",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      CustomColumn.new(response)
    end
    def update_custom_gradebook_column(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/custom_gradebook_columns/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      CustomColumn.new(response)
    end
    def delete_custom_gradebook_column(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/custom_gradebook_columns/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      CustomColumn.new(response)
    end
    def reorder_custom_columns(course_id,order,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :order,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "order is required" if order.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :order => order
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/custom_gradebook_columns/reorder",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def list_entries_for_column(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/custom_gradebook_columns/{id}/data",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|ColumnDatum.new(response)}
    end
    def update_column_data(course_id,id,user_id,column_data__content__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :column_data__content__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      raise "user_id is required" if user_id.nil?
      raise "column_data__content__ is required" if column_data__content__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id,
        :user_id => user_id,
        :column_data__content__ => column_data__content__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/custom_gradebook_columns/{id}/data/{user_id}",
        :course_id => course_id,
        :id => id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      ColumnDatum.new(response)
    end
    def list_discussion_topics_courses(course_id,order_by,opts={})
      query_param_keys = [
        :order_by,
        :scope,
        :only_announcements,
        :search_term
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "order_by is required" if order_by.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :order_by => order_by
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_discussion_topics_groups(group_id,order_by,opts={})
      query_param_keys = [
        :order_by,
        :scope,
        :only_announcements,
        :search_term
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "order_by is required" if order_by.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :order_by => order_by
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def create_new_discussion_topic_courses(course_id,title,message,discussion_type,podcast_enabled,podcast_has_student_posts,require_initial_post,assignment,is_announcement,position_after,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :message,
        :discussion_type,
        :published,
        :delayed_post_at,
        :lock_at,
        :podcast_enabled,
        :podcast_has_student_posts,
        :require_initial_post,
        :assignment,
        :is_announcement,
        :position_after,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "title is required" if title.nil?
      raise "message is required" if message.nil?
      raise "discussion_type is required" if discussion_type.nil?
      raise "podcast_enabled is required" if podcast_enabled.nil?
      raise "podcast_has_student_posts is required" if podcast_has_student_posts.nil?
      raise "require_initial_post is required" if require_initial_post.nil?
      raise "assignment is required" if assignment.nil?
      raise "is_announcement is required" if is_announcement.nil?
      raise "position_after is required" if position_after.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :title => title,
        :message => message,
        :discussion_type => discussion_type,
        :podcast_enabled => podcast_enabled,
        :podcast_has_student_posts => podcast_has_student_posts,
        :require_initial_post => require_initial_post,
        :assignment => assignment,
        :is_announcement => is_announcement,
        :position_after => position_after
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def create_new_discussion_topic_groups(group_id,title,message,discussion_type,podcast_enabled,podcast_has_student_posts,require_initial_post,assignment,is_announcement,position_after,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :message,
        :discussion_type,
        :published,
        :delayed_post_at,
        :lock_at,
        :podcast_enabled,
        :podcast_has_student_posts,
        :require_initial_post,
        :assignment,
        :is_announcement,
        :position_after,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "title is required" if title.nil?
      raise "message is required" if message.nil?
      raise "discussion_type is required" if discussion_type.nil?
      raise "podcast_enabled is required" if podcast_enabled.nil?
      raise "podcast_has_student_posts is required" if podcast_has_student_posts.nil?
      raise "require_initial_post is required" if require_initial_post.nil?
      raise "assignment is required" if assignment.nil?
      raise "is_announcement is required" if is_announcement.nil?
      raise "position_after is required" if position_after.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :title => title,
        :message => message,
        :discussion_type => discussion_type,
        :podcast_enabled => podcast_enabled,
        :podcast_has_student_posts => podcast_has_student_posts,
        :require_initial_post => require_initial_post,
        :assignment => assignment,
        :is_announcement => is_announcement,
        :position_after => position_after
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def create_new_discussion_topic_collection_items(collection_item_id,title,message,discussion_type,podcast_enabled,podcast_has_student_posts,require_initial_post,assignment,is_announcement,position_after,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :message,
        :discussion_type,
        :published,
        :delayed_post_at,
        :lock_at,
        :podcast_enabled,
        :podcast_has_student_posts,
        :require_initial_post,
        :assignment,
        :is_announcement,
        :position_after,
        
      ]

      # verify existence of params
      raise "collection_item_id is required" if collection_item_id.nil?
      raise "title is required" if title.nil?
      raise "message is required" if message.nil?
      raise "discussion_type is required" if discussion_type.nil?
      raise "podcast_enabled is required" if podcast_enabled.nil?
      raise "podcast_has_student_posts is required" if podcast_has_student_posts.nil?
      raise "require_initial_post is required" if require_initial_post.nil?
      raise "assignment is required" if assignment.nil?
      raise "is_announcement is required" if is_announcement.nil?
      raise "position_after is required" if position_after.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_item_id => collection_item_id,
        :title => title,
        :message => message,
        :discussion_type => discussion_type,
        :podcast_enabled => podcast_enabled,
        :podcast_has_student_posts => podcast_has_student_posts,
        :require_initial_post => require_initial_post,
        :assignment => assignment,
        :is_announcement => is_announcement,
        :position_after => position_after
      )

      # resource path
      path = path_replace("/v1/collection_items/{collection_item_id}/discussion_topics",
        :collection_item_id => collection_item_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def update_topic_courses(course_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def update_topic_groups(group_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def update_topic_collection_items(collection_item_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "collection_item_id is required" if collection_item_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_item_id => collection_item_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/collection_items/{collection_item_id}/discussion_topics/{topic_id}",
        :collection_item_id => collection_item_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def delete_topic_courses(course_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def delete_topic_groups(group_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def delete_topic_collection_items(collection_item_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "collection_item_id is required" if collection_item_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_item_id => collection_item_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/collection_items/{collection_item_id}/discussion_topics/{topic_id}",
        :collection_item_id => collection_item_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def update_entry_courses(course_id,topic_id,id,message,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :message,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "id is required" if id.nil?
      raise "message is required" if message.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id,
        :id => id,
        :message => message
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{id}",
        :course_id => course_id,
        :topic_id => topic_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def update_entry_groups(group_id,topic_id,id,message,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :message,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "id is required" if id.nil?
      raise "message is required" if message.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id,
        :id => id,
        :message => message
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{id}",
        :group_id => group_id,
        :topic_id => topic_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def update_entry_collection_items(collection_item_id,topic_id,id,message,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :message,
        
      ]

      # verify existence of params
      raise "collection_item_id is required" if collection_item_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "id is required" if id.nil?
      raise "message is required" if message.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_item_id => collection_item_id,
        :topic_id => topic_id,
        :id => id,
        :message => message
      )

      # resource path
      path = path_replace("/v1/collection_items/{collection_item_id}/discussion_topics/{topic_id}/entries/{id}",
        :collection_item_id => collection_item_id,
        :topic_id => topic_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def delete_entry_courses(course_id,topic_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{id}",
        :course_id => course_id,
        :topic_id => topic_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def delete_entry_groups(group_id,topic_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{id}",
        :group_id => group_id,
        :topic_id => topic_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def delete_entry_collection_items(collection_item_id,topic_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "collection_item_id is required" if collection_item_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_item_id => collection_item_id,
        :topic_id => topic_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/collection_items/{collection_item_id}/discussion_topics/{topic_id}/entries/{id}",
        :collection_item_id => collection_item_id,
        :topic_id => topic_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def get_single_topic_courses(course_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_single_topic_groups(group_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_single_topic_collection_items(collection_item_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "collection_item_id is required" if collection_item_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_item_id => collection_item_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/collection_items/{collection_item_id}/discussion_topics/{topic_id}",
        :collection_item_id => collection_item_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_the_full_topic_courses(course_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/view",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_the_full_topic_groups(group_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/view",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_the_full_topic_collection_items(collection_item_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "collection_item_id is required" if collection_item_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_item_id => collection_item_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/collection_items/{collection_item_id}/discussion_topics/{topic_id}/view",
        :collection_item_id => collection_item_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def post_entry_courses(course_id,topic_id,message,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :message,
        :attachment,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "message is required" if message.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id,
        :message => message
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/entries",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def post_entry_groups(group_id,topic_id,message,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :message,
        :attachment,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "message is required" if message.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id,
        :message => message
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/entries",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def post_entry_collection_items(collection_item_id,topic_id,message,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :message,
        :attachment,
        
      ]

      # verify existence of params
      raise "collection_item_id is required" if collection_item_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "message is required" if message.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_item_id => collection_item_id,
        :topic_id => topic_id,
        :message => message
      )

      # resource path
      path = path_replace("/v1/collection_items/{collection_item_id}/discussion_topics/{topic_id}/entries",
        :collection_item_id => collection_item_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def list_topic_entries_courses(course_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/entries",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_topic_entries_groups(group_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/entries",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_topic_entries_collection_items(collection_item_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "collection_item_id is required" if collection_item_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_item_id => collection_item_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/collection_items/{collection_item_id}/discussion_topics/{topic_id}/entries",
        :collection_item_id => collection_item_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def post_reply_courses(course_id,topic_id,entry_id,message,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :message,
        :attachment,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "entry_id is required" if entry_id.nil?
      raise "message is required" if message.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id,
        :entry_id => entry_id,
        :message => message
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies",
        :course_id => course_id,
        :topic_id => topic_id,
        :entry_id => entry_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def post_reply_groups(group_id,topic_id,entry_id,message,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :message,
        :attachment,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "entry_id is required" if entry_id.nil?
      raise "message is required" if message.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id,
        :entry_id => entry_id,
        :message => message
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies",
        :group_id => group_id,
        :topic_id => topic_id,
        :entry_id => entry_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def post_reply_collection_items(collection_item_id,topic_id,entry_id,message,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :message,
        :attachment,
        
      ]

      # verify existence of params
      raise "collection_item_id is required" if collection_item_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "entry_id is required" if entry_id.nil?
      raise "message is required" if message.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_item_id => collection_item_id,
        :topic_id => topic_id,
        :entry_id => entry_id,
        :message => message
      )

      # resource path
      path = path_replace("/v1/collection_items/{collection_item_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies",
        :collection_item_id => collection_item_id,
        :topic_id => topic_id,
        :entry_id => entry_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def list_entry_replies_courses(course_id,topic_id,entry_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "entry_id is required" if entry_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id,
        :entry_id => entry_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies",
        :course_id => course_id,
        :topic_id => topic_id,
        :entry_id => entry_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_entry_replies_groups(group_id,topic_id,entry_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "entry_id is required" if entry_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id,
        :entry_id => entry_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies",
        :group_id => group_id,
        :topic_id => topic_id,
        :entry_id => entry_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_entry_replies_collection_items(collection_item_id,topic_id,entry_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "collection_item_id is required" if collection_item_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "entry_id is required" if entry_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_item_id => collection_item_id,
        :topic_id => topic_id,
        :entry_id => entry_id
      )

      # resource path
      path = path_replace("/v1/collection_items/{collection_item_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies",
        :collection_item_id => collection_item_id,
        :topic_id => topic_id,
        :entry_id => entry_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_entries_courses(course_id,topic_id,ids,opts={})
      query_param_keys = [
        :ids
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "ids is required" if ids.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id,
        :ids => ids
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/entry_list",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_entries_groups(group_id,topic_id,ids,opts={})
      query_param_keys = [
        :ids
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "ids is required" if ids.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id,
        :ids => ids
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/entry_list",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_entries_collection_items(collection_item_id,topic_id,ids,opts={})
      query_param_keys = [
        :ids
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "collection_item_id is required" if collection_item_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "ids is required" if ids.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_item_id => collection_item_id,
        :topic_id => topic_id,
        :ids => ids
      )

      # resource path
      path = path_replace("/v1/collection_items/{collection_item_id}/discussion_topics/{topic_id}/entry_list",
        :collection_item_id => collection_item_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def mark_topic_as_read_courses(course_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/read",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def mark_topic_as_read_groups(group_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/read",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def mark_topic_as_read_collection_items(collection_item_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "collection_item_id is required" if collection_item_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_item_id => collection_item_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/collection_items/{collection_item_id}/discussion_topics/{topic_id}/read",
        :collection_item_id => collection_item_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def mark_topic_as_unread_courses(course_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/read",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def mark_topic_as_unread_groups(group_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/read",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def mark_topic_as_unread_collection_items(collection_item_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "collection_item_id is required" if collection_item_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_item_id => collection_item_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/collection_items/{collection_item_id}/discussion_topics/{topic_id}/read",
        :collection_item_id => collection_item_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def mark_all_entries_as_read_courses(course_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :forced_read_state,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/read_all",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def mark_all_entries_as_read_groups(group_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :forced_read_state,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/read_all",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def mark_all_entries_as_read_collection_items(collection_item_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :forced_read_state,
        
      ]

      # verify existence of params
      raise "collection_item_id is required" if collection_item_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_item_id => collection_item_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/collection_items/{collection_item_id}/discussion_topics/{topic_id}/read_all",
        :collection_item_id => collection_item_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def mark_all_entries_as_unread_courses(course_id,topic_id,opts={})
      query_param_keys = [
        :forced_read_state
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/read_all",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def mark_all_entries_as_unread_groups(group_id,topic_id,opts={})
      query_param_keys = [
        :forced_read_state
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/read_all",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def mark_all_entries_as_unread_collection_items(collection_item_id,topic_id,opts={})
      query_param_keys = [
        :forced_read_state
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "collection_item_id is required" if collection_item_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_item_id => collection_item_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/collection_items/{collection_item_id}/discussion_topics/{topic_id}/read_all",
        :collection_item_id => collection_item_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def mark_entry_as_read_courses(course_id,topic_id,entry_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :forced_read_state,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "entry_id is required" if entry_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id,
        :entry_id => entry_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/read",
        :course_id => course_id,
        :topic_id => topic_id,
        :entry_id => entry_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def mark_entry_as_read_groups(group_id,topic_id,entry_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :forced_read_state,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "entry_id is required" if entry_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id,
        :entry_id => entry_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/read",
        :group_id => group_id,
        :topic_id => topic_id,
        :entry_id => entry_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def mark_entry_as_read_collection_items(collection_item_id,topic_id,entry_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :forced_read_state,
        
      ]

      # verify existence of params
      raise "collection_item_id is required" if collection_item_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "entry_id is required" if entry_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_item_id => collection_item_id,
        :topic_id => topic_id,
        :entry_id => entry_id
      )

      # resource path
      path = path_replace("/v1/collection_items/{collection_item_id}/discussion_topics/{topic_id}/entries/{entry_id}/read",
        :collection_item_id => collection_item_id,
        :topic_id => topic_id,
        :entry_id => entry_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def mark_entry_as_unread_courses(course_id,topic_id,entry_id,opts={})
      query_param_keys = [
        :forced_read_state
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "entry_id is required" if entry_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id,
        :entry_id => entry_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/read",
        :course_id => course_id,
        :topic_id => topic_id,
        :entry_id => entry_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def mark_entry_as_unread_groups(group_id,topic_id,entry_id,opts={})
      query_param_keys = [
        :forced_read_state
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "entry_id is required" if entry_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id,
        :entry_id => entry_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/read",
        :group_id => group_id,
        :topic_id => topic_id,
        :entry_id => entry_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def mark_entry_as_unread_collection_items(collection_item_id,topic_id,entry_id,opts={})
      query_param_keys = [
        :forced_read_state
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "collection_item_id is required" if collection_item_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "entry_id is required" if entry_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_item_id => collection_item_id,
        :topic_id => topic_id,
        :entry_id => entry_id
      )

      # resource path
      path = path_replace("/v1/collection_items/{collection_item_id}/discussion_topics/{topic_id}/entries/{entry_id}/read",
        :collection_item_id => collection_item_id,
        :topic_id => topic_id,
        :entry_id => entry_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def subscribe_to_topic_courses(course_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/subscribed",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def subscribe_to_topic_groups(group_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/subscribed",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def subscribe_to_topic_collection_items(collection_item_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "collection_item_id is required" if collection_item_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_item_id => collection_item_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/collection_items/{collection_item_id}/discussion_topics/{topic_id}/subscribed",
        :collection_item_id => collection_item_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def unsubscribe_from_topic_courses(course_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/subscribed",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def unsubscribe_from_topic_groups(group_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/subscribed",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def unsubscribe_from_topic_collection_items(collection_item_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "collection_item_id is required" if collection_item_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :collection_item_id => collection_item_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/collection_items/{collection_item_id}/discussion_topics/{topic_id}/subscribed",
        :collection_item_id => collection_item_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def list_enrollments_courses(course_id,type,role,state,opts={})
      query_param_keys = [
        :type,
        :role,
        :state
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "type is required" if type.nil?
      raise "role is required" if role.nil?
      raise "state is required" if state.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :type => type,
        :role => role,
        :state => state
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/enrollments",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Enrollment.new(response)}
    end
    def list_enrollments_sections(section_id,type,role,state,opts={})
      query_param_keys = [
        :type,
        :role,
        :state
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "section_id is required" if section_id.nil?
      raise "type is required" if type.nil?
      raise "role is required" if role.nil?
      raise "state is required" if state.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :section_id => section_id,
        :type => type,
        :role => role,
        :state => state
      )

      # resource path
      path = path_replace("/v1/sections/{section_id}/enrollments",
        :section_id => section_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Enrollment.new(response)}
    end
    def list_enrollments_users(user_id,type,role,state,opts={})
      query_param_keys = [
        :type,
        :role,
        :state
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "type is required" if type.nil?
      raise "role is required" if role.nil?
      raise "state is required" if state.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :type => type,
        :role => role,
        :state => state
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/enrollments",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Enrollment.new(response)}
    end
    def enroll_user_courses(course_id,enrollment__user_id__,enrollment__type__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :enrollment__user_id__,
        :enrollment__type__,
        :enrollment__role__,
        :enrollment__enrollment_state__,
        :enrollment__course_section_id__,
        :enrollment__limit_privileges_to_course_section__,
        :enrollment__notify__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "enrollment__user_id__ is required" if enrollment__user_id__.nil?
      raise "enrollment__type__ is required" if enrollment__type__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :enrollment__user_id__ => enrollment__user_id__,
        :enrollment__type__ => enrollment__type__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/enrollments",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Enrollment.new(response)
    end
    def enroll_user_sections(section_id,enrollment__user_id__,enrollment__type__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :enrollment__user_id__,
        :enrollment__type__,
        :enrollment__role__,
        :enrollment__enrollment_state__,
        :enrollment__course_section_id__,
        :enrollment__limit_privileges_to_course_section__,
        :enrollment__notify__,
        
      ]

      # verify existence of params
      raise "section_id is required" if section_id.nil?
      raise "enrollment__user_id__ is required" if enrollment__user_id__.nil?
      raise "enrollment__type__ is required" if enrollment__type__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :section_id => section_id,
        :enrollment__user_id__ => enrollment__user_id__,
        :enrollment__type__ => enrollment__type__
      )

      # resource path
      path = path_replace("/v1/sections/{section_id}/enrollments",
        :section_id => section_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Enrollment.new(response)
    end
    def conclude_enrollment(course_id,id,task,opts={})
      query_param_keys = [
        :task
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      raise "task is required" if task.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id,
        :task => task
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/enrollments/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      Enrollment.new(response)
    end
    def list_external_tools_courses(course_id,opts={})
      query_param_keys = [
        :search_term
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/external_tools",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_external_tools_accounts(account_id,opts={})
      query_param_keys = [
        :search_term
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/external_tools",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_sessionless_launch_url_for_external_tool_courses(course_id,opts={})
      query_param_keys = [
        :id,
        :url,
        :assignment_id,
        :launch_type
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/external_tools/sessionless_launch",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_sessionless_launch_url_for_external_tool_accounts(account_id,opts={})
      query_param_keys = [
        :id,
        :url,
        :assignment_id,
        :launch_type
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/external_tools/sessionless_launch",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_single_external_tool_courses(course_id,external_tool_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "external_tool_id is required" if external_tool_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :external_tool_id => external_tool_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/external_tools/{external_tool_id}",
        :course_id => course_id,
        :external_tool_id => external_tool_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_single_external_tool_accounts(account_id,external_tool_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "external_tool_id is required" if external_tool_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :external_tool_id => external_tool_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/external_tools/{external_tool_id}",
        :account_id => account_id,
        :external_tool_id => external_tool_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def create_external_tool_courses(course_id,name,privacy_level,consumer_key,shared_secret,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :privacy_level,
        :consumer_key,
        :shared_secret,
        :description,
        :url,
        :domain,
        :icon_url,
        :text,
        :custom_fields,
        :account_navigation__url__,
        :account_navigation__enabled__,
        :account_navigation__text__,
        :user_navigation__url__,
        :user_navigation__enabled__,
        :user_navigation__text__,
        :course_navigation__url__,
        :course_navigation__enabled__,
        :course_navigation__text__,
        :course_navigation__visibility__,
        :course_navigation__default__,
        :editor_button__url__,
        :editor_button__enabled__,
        :editor_button__icon_url__,
        :editor_button__selection_width__,
        :editor_button__selection_height__,
        :resource_selection__url__,
        :resource_selection__enabled__,
        :resource_selection__icon_url__,
        :resource_selection__selection_width__,
        :resource_selection__selection_height__,
        :config_type,
        :config_xml,
        :config_url,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "name is required" if name.nil?
      raise "privacy_level is required" if privacy_level.nil?
      raise "consumer_key is required" if consumer_key.nil?
      raise "shared_secret is required" if shared_secret.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :name => name,
        :privacy_level => privacy_level,
        :consumer_key => consumer_key,
        :shared_secret => shared_secret
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/external_tools",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def create_external_tool_accounts(account_id,name,privacy_level,consumer_key,shared_secret,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :privacy_level,
        :consumer_key,
        :shared_secret,
        :description,
        :url,
        :domain,
        :icon_url,
        :text,
        :custom_fields,
        :account_navigation__url__,
        :account_navigation__enabled__,
        :account_navigation__text__,
        :user_navigation__url__,
        :user_navigation__enabled__,
        :user_navigation__text__,
        :course_navigation__url__,
        :course_navigation__enabled__,
        :course_navigation__text__,
        :course_navigation__visibility__,
        :course_navigation__default__,
        :editor_button__url__,
        :editor_button__enabled__,
        :editor_button__icon_url__,
        :editor_button__selection_width__,
        :editor_button__selection_height__,
        :resource_selection__url__,
        :resource_selection__enabled__,
        :resource_selection__icon_url__,
        :resource_selection__selection_width__,
        :resource_selection__selection_height__,
        :config_type,
        :config_xml,
        :config_url,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "name is required" if name.nil?
      raise "privacy_level is required" if privacy_level.nil?
      raise "consumer_key is required" if consumer_key.nil?
      raise "shared_secret is required" if shared_secret.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :name => name,
        :privacy_level => privacy_level,
        :consumer_key => consumer_key,
        :shared_secret => shared_secret
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/external_tools",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def edit_external_tool_courses(course_id,external_tool_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "external_tool_id is required" if external_tool_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :external_tool_id => external_tool_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/external_tools/{external_tool_id}",
        :course_id => course_id,
        :external_tool_id => external_tool_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def edit_external_tool_accounts(account_id,external_tool_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "external_tool_id is required" if external_tool_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :external_tool_id => external_tool_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/external_tools/{external_tool_id}",
        :account_id => account_id,
        :external_tool_id => external_tool_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def delete_external_tool_courses(course_id,external_tool_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "external_tool_id is required" if external_tool_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :external_tool_id => external_tool_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/external_tools/{external_tool_id}",
        :course_id => course_id,
        :external_tool_id => external_tool_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def delete_external_tool_accounts(account_id,external_tool_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "external_tool_id is required" if external_tool_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :external_tool_id => external_tool_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/external_tools/{external_tool_id}",
        :account_id => account_id,
        :external_tool_id => external_tool_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def list_favorite_courses(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/users/self/favorites/courses",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Course.new(response)}
    end
    def add_course_to_favorites(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/users/self/favorites/courses/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Favorite.new(response)
    end
    def remove_course_from_favorites(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/users/self/favorites/courses/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      Favorite.new(response)
    end
    def reset_course_favorites(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/users/self/favorites/courses",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def list_features_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/features",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Feature.new(response)}
    end
    def list_features_accounts(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/features",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Feature.new(response)}
    end
    def list_features_users(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/features",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Feature.new(response)}
    end
    def list_enabled_features_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/features/enabled",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_enabled_features_accounts(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/features/enabled",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_enabled_features_users(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/features/enabled",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_feature_flag_courses(course_id,feature,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "feature is required" if feature.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :feature => feature
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/features/flags/{feature}",
        :course_id => course_id,
        :feature => feature)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      FeatureFlag.new(response)
    end
    def get_feature_flag_accounts(account_id,feature,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "feature is required" if feature.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :feature => feature
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/features/flags/{feature}",
        :account_id => account_id,
        :feature => feature)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      FeatureFlag.new(response)
    end
    def get_feature_flag_users(user_id,feature,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "feature is required" if feature.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :feature => feature
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/features/flags/{feature}",
        :user_id => user_id,
        :feature => feature)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      FeatureFlag.new(response)
    end
    def set_feature_flag_courses(course_id,feature,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :state,
        :locking_account_id,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "feature is required" if feature.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :feature => feature
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/features/flags/{feature}",
        :course_id => course_id,
        :feature => feature)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      FeatureFlag.new(response)
    end
    def set_feature_flag_accounts(account_id,feature,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :state,
        :locking_account_id,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "feature is required" if feature.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :feature => feature
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/features/flags/{feature}",
        :account_id => account_id,
        :feature => feature)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      FeatureFlag.new(response)
    end
    def set_feature_flag_users(user_id,feature,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :state,
        :locking_account_id,
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "feature is required" if feature.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :feature => feature
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/features/flags/{feature}",
        :user_id => user_id,
        :feature => feature)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      FeatureFlag.new(response)
    end
    def remove_feature_flag_courses(course_id,feature,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "feature is required" if feature.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :feature => feature
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/features/flags/{feature}",
        :course_id => course_id,
        :feature => feature)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      FeatureFlag.new(response)
    end
    def remove_feature_flag_accounts(account_id,feature,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "feature is required" if feature.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :feature => feature
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/features/flags/{feature}",
        :account_id => account_id,
        :feature => feature)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      FeatureFlag.new(response)
    end
    def remove_feature_flag_users(user_id,feature,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "feature is required" if feature.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :feature => feature
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/features/flags/{feature}",
        :user_id => user_id,
        :feature => feature)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      FeatureFlag.new(response)
    end
    def list_files_courses(course_id,opts={})
      query_param_keys = [
        :content_types,
        :search_term
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/files",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|File.new(response)}
    end
    def list_files_folders(id,opts={})
      query_param_keys = [
        :content_types,
        :search_term
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/folders/{id}/files",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|File.new(response)}
    end
    def get_file(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/files/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      File.new(response)
    end
    def update_file(id,name,parent_folder_id,lock_at,unlock_at,locked,hidden,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :parent_folder_id,
        :lock_at,
        :unlock_at,
        :locked,
        :hidden,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "name is required" if name.nil?
      raise "parent_folder_id is required" if parent_folder_id.nil?
      raise "lock_at is required" if lock_at.nil?
      raise "unlock_at is required" if unlock_at.nil?
      raise "locked is required" if locked.nil?
      raise "hidden is required" if hidden.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :name => name,
        :parent_folder_id => parent_folder_id,
        :lock_at => lock_at,
        :unlock_at => unlock_at,
        :locked => locked,
        :hidden => hidden
      )

      # resource path
      path = path_replace("/v1/files/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      File.new(response)
    end
    def delete_file(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/files/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def list_folders(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/folders/{id}/folders",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Folder.new(response)}
    end
    def get_folder_courses(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/folders/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      Folder.new(response)
    end
    def get_folder_users(user_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/folders/{id}",
        :user_id => user_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      Folder.new(response)
    end
    def get_folder_groups(group_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/folders/{id}",
        :group_id => group_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      Folder.new(response)
    end
    def get_folder_folders(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/folders/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      Folder.new(response)
    end
    def update_folder(id,name,parent_folder_id,lock_at,unlock_at,locked,hidden,position,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :parent_folder_id,
        :lock_at,
        :unlock_at,
        :locked,
        :hidden,
        :position,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "name is required" if name.nil?
      raise "parent_folder_id is required" if parent_folder_id.nil?
      raise "lock_at is required" if lock_at.nil?
      raise "unlock_at is required" if unlock_at.nil?
      raise "locked is required" if locked.nil?
      raise "hidden is required" if hidden.nil?
      raise "position is required" if position.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :name => name,
        :parent_folder_id => parent_folder_id,
        :lock_at => lock_at,
        :unlock_at => unlock_at,
        :locked => locked,
        :hidden => hidden,
        :position => position
      )

      # resource path
      path = path_replace("/v1/folders/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      Folder.new(response)
    end
    def create_folder_courses(course_id,name,parent_folder_id,parent_folder_path,lock_at,unlock_at,locked,hidden,position,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :parent_folder_id,
        :parent_folder_path,
        :lock_at,
        :unlock_at,
        :locked,
        :hidden,
        :position,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "name is required" if name.nil?
      raise "parent_folder_id is required" if parent_folder_id.nil?
      raise "parent_folder_path is required" if parent_folder_path.nil?
      raise "lock_at is required" if lock_at.nil?
      raise "unlock_at is required" if unlock_at.nil?
      raise "locked is required" if locked.nil?
      raise "hidden is required" if hidden.nil?
      raise "position is required" if position.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :name => name,
        :parent_folder_id => parent_folder_id,
        :parent_folder_path => parent_folder_path,
        :lock_at => lock_at,
        :unlock_at => unlock_at,
        :locked => locked,
        :hidden => hidden,
        :position => position
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/folders",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Folder.new(response)
    end
    def create_folder_users(user_id,name,parent_folder_id,parent_folder_path,lock_at,unlock_at,locked,hidden,position,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :parent_folder_id,
        :parent_folder_path,
        :lock_at,
        :unlock_at,
        :locked,
        :hidden,
        :position,
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "name is required" if name.nil?
      raise "parent_folder_id is required" if parent_folder_id.nil?
      raise "parent_folder_path is required" if parent_folder_path.nil?
      raise "lock_at is required" if lock_at.nil?
      raise "unlock_at is required" if unlock_at.nil?
      raise "locked is required" if locked.nil?
      raise "hidden is required" if hidden.nil?
      raise "position is required" if position.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :name => name,
        :parent_folder_id => parent_folder_id,
        :parent_folder_path => parent_folder_path,
        :lock_at => lock_at,
        :unlock_at => unlock_at,
        :locked => locked,
        :hidden => hidden,
        :position => position
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/folders",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Folder.new(response)
    end
    def create_folder_groups(group_id,name,parent_folder_id,parent_folder_path,lock_at,unlock_at,locked,hidden,position,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :parent_folder_id,
        :parent_folder_path,
        :lock_at,
        :unlock_at,
        :locked,
        :hidden,
        :position,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "name is required" if name.nil?
      raise "parent_folder_id is required" if parent_folder_id.nil?
      raise "parent_folder_path is required" if parent_folder_path.nil?
      raise "lock_at is required" if lock_at.nil?
      raise "unlock_at is required" if unlock_at.nil?
      raise "locked is required" if locked.nil?
      raise "hidden is required" if hidden.nil?
      raise "position is required" if position.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :name => name,
        :parent_folder_id => parent_folder_id,
        :parent_folder_path => parent_folder_path,
        :lock_at => lock_at,
        :unlock_at => unlock_at,
        :locked => locked,
        :hidden => hidden,
        :position => position
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/folders",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Folder.new(response)
    end
    def create_folder_folders(folder_id,name,parent_folder_id,parent_folder_path,lock_at,unlock_at,locked,hidden,position,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :parent_folder_id,
        :parent_folder_path,
        :lock_at,
        :unlock_at,
        :locked,
        :hidden,
        :position,
        
      ]

      # verify existence of params
      raise "folder_id is required" if folder_id.nil?
      raise "name is required" if name.nil?
      raise "parent_folder_id is required" if parent_folder_id.nil?
      raise "parent_folder_path is required" if parent_folder_path.nil?
      raise "lock_at is required" if lock_at.nil?
      raise "unlock_at is required" if unlock_at.nil?
      raise "locked is required" if locked.nil?
      raise "hidden is required" if hidden.nil?
      raise "position is required" if position.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :folder_id => folder_id,
        :name => name,
        :parent_folder_id => parent_folder_id,
        :parent_folder_path => parent_folder_path,
        :lock_at => lock_at,
        :unlock_at => unlock_at,
        :locked => locked,
        :hidden => hidden,
        :position => position
      )

      # resource path
      path = path_replace("/v1/folders/{folder_id}/folders",
        :folder_id => folder_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Folder.new(response)
    end
    def delete_folder(id,force,opts={})
      query_param_keys = [
        :force
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "force is required" if force.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :force => force
      )

      # resource path
      path = path_replace("/v1/folders/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def upload_file(folder_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "folder_id is required" if folder_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :folder_id => folder_id
      )

      # resource path
      path = path_replace("/v1/folders/{folder_id}/files",
        :folder_id => folder_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def query_by_assignment(assignment_id,opts={})
      query_param_keys = [
        :start_time,
        :end_time
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "assignment_id is required" if assignment_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :assignment_id => assignment_id
      )

      # resource path
      path = path_replace("/v1/audit/grade_change/assignments/{assignment_id}",
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|GradeChangeEvent.new(response)}
    end
    def query_by_course(course_id,opts={})
      query_param_keys = [
        :start_time,
        :end_time
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/audit/grade_change/courses/{course_id}",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|GradeChangeEvent.new(response)}
    end
    def query_by_student(student_id,opts={})
      query_param_keys = [
        :start_time,
        :end_time
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "student_id is required" if student_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :student_id => student_id
      )

      # resource path
      path = path_replace("/v1/audit/grade_change/students/{student_id}",
        :student_id => student_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|GradeChangeEvent.new(response)}
    end
    def query_by_grader(grader_id,opts={})
      query_param_keys = [
        :start_time,
        :end_time
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "grader_id is required" if grader_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :grader_id => grader_id
      )

      # resource path
      path = path_replace("/v1/audit/grade_change/graders/{grader_id}",
        :grader_id => grader_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|GradeChangeEvent.new(response)}
    end
    def days_in_gradebook_history_for_this_course(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/gradebook_history/days",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Day.new(response)}
    end
    def details_for_given_date_in_gradebook_history_for_this_course(course_id,date,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "date is required" if date.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :date => date
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/gradebook_history/{date}",
        :course_id => course_id,
        :date => date)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Grader.new(response)}
    end
    def lists_submissions(course_id,date,grader_id,assignment_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "date is required" if date.nil?
      raise "grader_id is required" if grader_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :date => date,
        :grader_id => grader_id,
        :assignment_id => assignment_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/gradebook_history/{date}/graders/{grader_id}/assignments/{assignment_id}/submissions",
        :course_id => course_id,
        :date => date,
        :grader_id => grader_id,
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|SubmissionHistory.new(response)}
    end
    def list_uncollated_submission_versions(course_id,opts={})
      query_param_keys = [
        :assignment_id,
        :user_id,
        :ascending
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/gradebook_history/feed",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|SubmissionVersion.new(response)}
    end
    def list_group_categories_for_context_accounts(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/group_categories",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|GroupCategory.new(response)}
    end
    def list_group_categories_for_context_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/group_categories",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|GroupCategory.new(response)}
    end
    def get_single_group_category(group_category_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_category_id is required" if group_category_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_category_id => group_category_id
      )

      # resource path
      path = path_replace("/v1/group_categories/{group_category_id}",
        :group_category_id => group_category_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      GroupCategory.new(response)
    end
    def create_group_category_accounts(account_id,name,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :self_signup,
        :group_limit,
        :create_group_count,
        :split_group_count,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "name is required" if name.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :name => name
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/group_categories",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      GroupCategory.new(response)
    end
    def create_group_category_courses(course_id,name,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :self_signup,
        :group_limit,
        :create_group_count,
        :split_group_count,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "name is required" if name.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :name => name
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/group_categories",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      GroupCategory.new(response)
    end
    def update_group_category(group_category_id,name,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :self_signup,
        :group_limit,
        :create_group_count,
        :split_group_count,
        
      ]

      # verify existence of params
      raise "group_category_id is required" if group_category_id.nil?
      raise "name is required" if name.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_category_id => group_category_id,
        :name => name
      )

      # resource path
      path = path_replace("/v1/group_categories/{group_category_id}",
        :group_category_id => group_category_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      GroupCategory.new(response)
    end
    def delete_group_category(group_category_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_category_id is required" if group_category_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_category_id => group_category_id
      )

      # resource path
      path = path_replace("/v1/group_categories/{group_category_id}",
        :group_category_id => group_category_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def list_groups_in_group_category(group_category_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_category_id is required" if group_category_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_category_id => group_category_id
      )

      # resource path
      path = path_replace("/v1/group_categories/{group_category_id}/groups",
        :group_category_id => group_category_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Groups.new(response)}
    end
    def list_users_in_group_category(group_category_id,opts={})
      query_param_keys = [
        :search_term,
        :unassigned
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_category_id is required" if group_category_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_category_id => group_category_id
      )

      # resource path
      path = path_replace("/v1/group_categories/{group_category_id}/users",
        :group_category_id => group_category_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|User.new(response)}
    end
    def assign_unassigned_members(group_category_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :sync,
        
      ]

      # verify existence of params
      raise "group_category_id is required" if group_category_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_category_id => group_category_id
      )

      # resource path
      path = path_replace("/v1/group_categories/{group_category_id}/assign_unassigned_members",
        :group_category_id => group_category_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      GroupMembership | Progress.new(response)
    end
    def list_your_groups(opts={})
      query_param_keys = [
        :context_type
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/users/self/groups",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Group.new(response)}
    end
    def list_the_groups_available_in_context_accounts(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/groups",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Group.new(response)}
    end
    def list_the_groups_available_in_context_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/groups",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Group.new(response)}
    end
    def get_single_group(group_id,include,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :include => include
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      Group.new(response)
    end
    def create_group_groups(name,description,is_public,join_level,storage_quota_mb,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :description,
        :is_public,
        :join_level,
        :storage_quota_mb,
        
      ]

      # verify existence of params
      raise "name is required" if name.nil?
      raise "description is required" if description.nil?
      raise "is_public is required" if is_public.nil?
      raise "join_level is required" if join_level.nil?
      raise "storage_quota_mb is required" if storage_quota_mb.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :name => name,
        :description => description,
        :is_public => is_public,
        :join_level => join_level,
        :storage_quota_mb => storage_quota_mb
      )

      # resource path
      path = path_replace("/v1/groups",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Group.new(response)
    end
    def create_group_group_categories(group_category_id,name,description,is_public,join_level,storage_quota_mb,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :description,
        :is_public,
        :join_level,
        :storage_quota_mb,
        
      ]

      # verify existence of params
      raise "group_category_id is required" if group_category_id.nil?
      raise "name is required" if name.nil?
      raise "description is required" if description.nil?
      raise "is_public is required" if is_public.nil?
      raise "join_level is required" if join_level.nil?
      raise "storage_quota_mb is required" if storage_quota_mb.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_category_id => group_category_id,
        :name => name,
        :description => description,
        :is_public => is_public,
        :join_level => join_level,
        :storage_quota_mb => storage_quota_mb
      )

      # resource path
      path = path_replace("/v1/group_categories/{group_category_id}/groups",
        :group_category_id => group_category_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Group.new(response)
    end
    def edit_group(group_id,name,description,is_public,join_level,avatar_id,storage_quota_mb,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :description,
        :is_public,
        :join_level,
        :avatar_id,
        :storage_quota_mb,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "name is required" if name.nil?
      raise "description is required" if description.nil?
      raise "is_public is required" if is_public.nil?
      raise "join_level is required" if join_level.nil?
      raise "avatar_id is required" if avatar_id.nil?
      raise "storage_quota_mb is required" if storage_quota_mb.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :name => name,
        :description => description,
        :is_public => is_public,
        :join_level => join_level,
        :avatar_id => avatar_id,
        :storage_quota_mb => storage_quota_mb
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      Group.new(response)
    end
    def delete_group(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      Group.new(response)
    end
    def follow_group(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/followers/self",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def un_follow_group(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/followers/self",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def invite_others_to_group(group_id,invitees,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :invitees,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "invitees is required" if invitees.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :invitees => invitees
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/invite",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def list_group_s_users(group_id,opts={})
      query_param_keys = [
        :search_term
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/users",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|User.new(response)}
    end
    def upload_file(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/files",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def preview_processed_html(group_id,html,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :html,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "html is required" if html.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :html => html
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/preview_html",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def group_activity_stream(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/activity_stream",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def group_activity_stream_summary(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/activity_stream/summary",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_group_memberships_groups(group_id,opts={})
      query_param_keys = [
        :filter_states
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/memberships",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|GroupMembership.new(response)}
    end
    def list_group_memberships_groups(group_id,opts={})
      query_param_keys = [
        :filter_states
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/users",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|GroupMembership.new(response)}
    end
    def create_membership(group_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :user_id,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/memberships",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      GroupMembership.new(response)
    end
    def update_membership_groups(group_id,membership_id,moderator,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :workflow_state,
        :moderator,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "membership_id is required" if membership_id.nil?
      raise "moderator is required" if moderator.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :membership_id => membership_id,
        :moderator => moderator
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/memberships/{membership_id}",
        :group_id => group_id,
        :membership_id => membership_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      GroupMembership.new(response)
    end
    def update_membership_groups(group_id,user_id,moderator,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :workflow_state,
        :moderator,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "user_id is required" if user_id.nil?
      raise "moderator is required" if moderator.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :user_id => user_id,
        :moderator => moderator
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/users/{user_id}",
        :group_id => group_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      GroupMembership.new(response)
    end
    def leave_group_groups(group_id,membership_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "membership_id is required" if membership_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :membership_id => membership_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/memberships/{membership_id}",
        :group_id => group_id,
        :membership_id => membership_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def leave_group_groups(group_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/users/{user_id}",
        :group_id => group_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def list_user_logins_accounts(account_id,user__id__,opts={})
      query_param_keys = [
        :user__id__
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "user__id__ is required" if user__id__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :user__id__ => user__id__
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/logins",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_user_logins_users(user_id,user__id__,opts={})
      query_param_keys = [
        :user__id__
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "user__id__ is required" if user__id__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :user__id__ => user__id__
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/logins",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def create_user_login(account_id,user__id__,login__unique_id__,login__password__,login__sis_user_id__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :user__id__,
        :login__unique_id__,
        :login__password__,
        :login__sis_user_id__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "user__id__ is required" if user__id__.nil?
      raise "login__unique_id__ is required" if login__unique_id__.nil?
      raise "login__password__ is required" if login__password__.nil?
      raise "login__sis_user_id__ is required" if login__sis_user_id__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :user__id__ => user__id__,
        :login__unique_id__ => login__unique_id__,
        :login__password__ => login__password__,
        :login__sis_user_id__ => login__sis_user_id__
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/logins",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def edit_user_login(account_id,id,login__unique_id__,login__password__,login__sis_user_id__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :login__unique_id__,
        :login__password__,
        :login__sis_user_id__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      raise "login__unique_id__ is required" if login__unique_id__.nil?
      raise "login__password__ is required" if login__password__.nil?
      raise "login__sis_user_id__ is required" if login__sis_user_id__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id,
        :login__unique_id__ => login__unique_id__,
        :login__password__ => login__password__,
        :login__sis_user_id__ => login__sis_user_id__
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/logins/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def delete_user_login(user_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/logins/{id}",
        :user_id => user_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def list_modules(course_id,include,opts={})
      query_param_keys = [
        :include,
        :search_term,
        :student_id
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :include => include
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Module.new(response)}
    end
    def show_module(course_id,id,include,opts={})
      query_param_keys = [
        :include,
        :student_id
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id,
        :include => include
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      Module.new(response)
    end
    def create_module(course_id,module__name__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :module__name__,
        :module__unlock_at__,
        :module__position__,
        :module__require_sequential_progress__,
        :module__prerequisite_module_ids__,
        :module__publish_final_grade__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "module__name__ is required" if module__name__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :module__name__ => module__name__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Module.new(response)
    end
    def update_module(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :module__name__,
        :module__unlock_at__,
        :module__position__,
        :module__require_sequential_progress__,
        :module__prerequisite_module_ids__,
        :module__publish_final_grade__,
        :module__published__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      Module.new(response)
    end
    def delete_module(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      Module.new(response)
    end
    def list_module_items(course_id,module_id,include,opts={})
      query_param_keys = [
        :include,
        :search_term,
        :student_id
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "module_id is required" if module_id.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :module_id => module_id,
        :include => include
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules/{module_id}/items",
        :course_id => course_id,
        :module_id => module_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|ModuleItem.new(response)}
    end
    def show_module_item(course_id,module_id,id,include,opts={})
      query_param_keys = [
        :include,
        :student_id
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "module_id is required" if module_id.nil?
      raise "id is required" if id.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :module_id => module_id,
        :id => id,
        :include => include
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules/{module_id}/items/{id}",
        :course_id => course_id,
        :module_id => module_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      ModuleItem.new(response)
    end
    def create_module_item(course_id,module_id,module_item__type__,module_item__content_id__,module_item__page_url__,module_item__external_url__,module_item__completion_requirement____min_score__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :module_item__title__,
        :module_item__type__,
        :module_item__content_id__,
        :module_item__position__,
        :module_item__indent__,
        :module_item__page_url__,
        :module_item__external_url__,
        :module_item__new_tab__,
        :module_item__completion_requirement____type__,
        :module_item__completion_requirement____min_score__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "module_id is required" if module_id.nil?
      raise "module_item__type__ is required" if module_item__type__.nil?
      raise "module_item__content_id__ is required" if module_item__content_id__.nil?
      raise "module_item__page_url__ is required" if module_item__page_url__.nil?
      raise "module_item__external_url__ is required" if module_item__external_url__.nil?
      raise "module_item__completion_requirement____min_score__ is required" if module_item__completion_requirement____min_score__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :module_id => module_id,
        :module_item__type__ => module_item__type__,
        :module_item__content_id__ => module_item__content_id__,
        :module_item__page_url__ => module_item__page_url__,
        :module_item__external_url__ => module_item__external_url__,
        :module_item__completion_requirement____min_score__ => module_item__completion_requirement____min_score__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules/{module_id}/items",
        :course_id => course_id,
        :module_id => module_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      ModuleItem.new(response)
    end
    def update_module_item(course_id,module_id,id,module_item__completion_requirement____min_score__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :module_item__title__,
        :module_item__position__,
        :module_item__indent__,
        :module_item__external_url__,
        :module_item__new_tab__,
        :module_item__completion_requirement____type__,
        :module_item__completion_requirement____min_score__,
        :module_item__published__,
        :module_item__module_id__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "module_id is required" if module_id.nil?
      raise "id is required" if id.nil?
      raise "module_item__completion_requirement____min_score__ is required" if module_item__completion_requirement____min_score__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :module_id => module_id,
        :id => id,
        :module_item__completion_requirement____min_score__ => module_item__completion_requirement____min_score__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules/{module_id}/items/{id}",
        :course_id => course_id,
        :module_id => module_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      ModuleItem.new(response)
    end
    def delete_module_item(course_id,module_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "module_id is required" if module_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :module_id => module_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules/{module_id}/items/{id}",
        :course_id => course_id,
        :module_id => module_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      ModuleItem.new(response)
    end
    def get_module_item_sequence(course_id,asset_type,asset_id,opts={})
      query_param_keys = [
        :asset_type,
        :asset_id
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "asset_type is required" if asset_type.nil?
      raise "asset_id is required" if asset_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :asset_type => asset_type,
        :asset_id => asset_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/module_item_sequence",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      ModuleItemSequence.new(response)
    end
    def list_preferences_users(user_id,communication_channel_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "communication_channel_id is required" if communication_channel_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :communication_channel_id => communication_channel_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/communication_channels/{communication_channel_id}/notification_preferences",
        :user_id => user_id,
        :communication_channel_id => communication_channel_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|NotificationPreference.new(response)}
    end
    def list_preferences_users(user_id,type,address,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "type is required" if type.nil?
      raise "address is required" if address.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :type => type,
        :address => address
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/communication_channels/{type}/{address}/notification_preferences",
        :user_id => user_id,
        :type => type,
        :address => address)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|NotificationPreference.new(response)}
    end
    def get_preference_users(user_id,communication_channel_id,notification,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "communication_channel_id is required" if communication_channel_id.nil?
      raise "notification is required" if notification.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :communication_channel_id => communication_channel_id,
        :notification => notification
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/communication_channels/{communication_channel_id}/notification_preferences/{notification}",
        :user_id => user_id,
        :communication_channel_id => communication_channel_id,
        :notification => notification)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      NotificationPreference.new(response)
    end
    def get_preference_users(user_id,type,address,notification,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "type is required" if type.nil?
      raise "address is required" if address.nil?
      raise "notification is required" if notification.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :type => type,
        :address => address,
        :notification => notification
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/communication_channels/{type}/{address}/notification_preferences/{notification}",
        :user_id => user_id,
        :type => type,
        :address => address,
        :notification => notification)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      NotificationPreference.new(response)
    end
    def update_preference_users(communication_channel_id,notification,notification_preferences__frequency__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :notification_preferences__frequency__,
        
      ]

      # verify existence of params
      raise "communication_channel_id is required" if communication_channel_id.nil?
      raise "notification is required" if notification.nil?
      raise "notification_preferences__frequency__ is required" if notification_preferences__frequency__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :communication_channel_id => communication_channel_id,
        :notification => notification,
        :notification_preferences__frequency__ => notification_preferences__frequency__
      )

      # resource path
      path = path_replace("/v1/users/self/communication_channels/{communication_channel_id}/notification_preferences/{notification}",
        :communication_channel_id => communication_channel_id,
        :notification => notification)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def update_preference_users(type,address,notification,notification_preferences__frequency__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :notification_preferences__frequency__,
        
      ]

      # verify existence of params
      raise "type is required" if type.nil?
      raise "address is required" if address.nil?
      raise "notification is required" if notification.nil?
      raise "notification_preferences__frequency__ is required" if notification_preferences__frequency__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :type => type,
        :address => address,
        :notification => notification,
        :notification_preferences__frequency__ => notification_preferences__frequency__
      )

      # resource path
      path = path_replace("/v1/users/self/communication_channels/{type}/{address}/notification_preferences/{notification}",
        :type => type,
        :address => address,
        :notification => notification)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def update_multiple_preferences_users(communication_channel_id,notification_preferences____x_____frequency__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :notification_preferences____x_____frequency__,
        
      ]

      # verify existence of params
      raise "communication_channel_id is required" if communication_channel_id.nil?
      raise "notification_preferences____x_____frequency__ is required" if notification_preferences____x_____frequency__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :communication_channel_id => communication_channel_id,
        :notification_preferences____x_____frequency__ => notification_preferences____x_____frequency__
      )

      # resource path
      path = path_replace("/v1/users/self/communication_channels/{communication_channel_id}/notification_preferences",
        :communication_channel_id => communication_channel_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def update_multiple_preferences_users(type,address,notification_preferences____x_____frequency__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :notification_preferences____x_____frequency__,
        
      ]

      # verify existence of params
      raise "type is required" if type.nil?
      raise "address is required" if address.nil?
      raise "notification_preferences____x_____frequency__ is required" if notification_preferences____x_____frequency__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :type => type,
        :address => address,
        :notification_preferences____x_____frequency__ => notification_preferences____x_____frequency__
      )

      # resource path
      path = path_replace("/v1/users/self/communication_channels/{type}/{address}/notification_preferences",
        :type => type,
        :address => address)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def redirect_to_root_outcome_group_for_context_global(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/global/root_outcome_group",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def redirect_to_root_outcome_group_for_context_accounts(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/root_outcome_group",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def redirect_to_root_outcome_group_for_context_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/root_outcome_group",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def show_outcome_group_global(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/global/outcome_groups/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      OutcomeGroup.new(response)
    end
    def show_outcome_group_accounts(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_groups/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      OutcomeGroup.new(response)
    end
    def show_outcome_group_courses(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_groups/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      OutcomeGroup.new(response)
    end
    def update_outcome_group_global(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :description,
        :vendor_guid,
        :parent_outcome_group_id,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/global/outcome_groups/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      OutcomeGroup.new(response)
    end
    def update_outcome_group_accounts(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :description,
        :vendor_guid,
        :parent_outcome_group_id,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_groups/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      OutcomeGroup.new(response)
    end
    def update_outcome_group_courses(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :description,
        :vendor_guid,
        :parent_outcome_group_id,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_groups/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      OutcomeGroup.new(response)
    end
    def delete_outcome_group_global(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/global/outcome_groups/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      OutcomeGroup.new(response)
    end
    def delete_outcome_group_accounts(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_groups/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      OutcomeGroup.new(response)
    end
    def delete_outcome_group_courses(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_groups/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      OutcomeGroup.new(response)
    end
    def list_linked_outcomes_global(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/global/outcome_groups/{id}/outcomes",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|OutcomeLink.new(response)}
    end
    def list_linked_outcomes_accounts(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_groups/{id}/outcomes",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|OutcomeLink.new(response)}
    end
    def list_linked_outcomes_courses(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_groups/{id}/outcomes",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|OutcomeLink.new(response)}
    end
    def create_link_outcome_global(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :outcome_id,
        :title,
        :description,
        :vendor_guid,
        :mastery_points,
        :ratings__description__,
        :ratings__points__,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/global/outcome_groups/{id}/outcomes",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      OutcomeLink.new(response)
    end
    def create_link_outcome_global(id,outcome_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :description,
        :vendor_guid,
        :mastery_points,
        :ratings__description__,
        :ratings__points__,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "outcome_id is required" if outcome_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :outcome_id => outcome_id
      )

      # resource path
      path = path_replace("/v1/global/outcome_groups/{id}/outcomes/{outcome_id}",
        :id => id,
        :outcome_id => outcome_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      OutcomeLink.new(response)
    end
    def create_link_outcome_accounts(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :outcome_id,
        :title,
        :description,
        :vendor_guid,
        :mastery_points,
        :ratings__description__,
        :ratings__points__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_groups/{id}/outcomes",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      OutcomeLink.new(response)
    end
    def create_link_outcome_accounts(account_id,id,outcome_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :description,
        :vendor_guid,
        :mastery_points,
        :ratings__description__,
        :ratings__points__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      raise "outcome_id is required" if outcome_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id,
        :outcome_id => outcome_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_groups/{id}/outcomes/{outcome_id}",
        :account_id => account_id,
        :id => id,
        :outcome_id => outcome_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      OutcomeLink.new(response)
    end
    def create_link_outcome_courses(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :outcome_id,
        :title,
        :description,
        :vendor_guid,
        :mastery_points,
        :ratings__description__,
        :ratings__points__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_groups/{id}/outcomes",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      OutcomeLink.new(response)
    end
    def create_link_outcome_courses(course_id,id,outcome_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :description,
        :vendor_guid,
        :mastery_points,
        :ratings__description__,
        :ratings__points__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      raise "outcome_id is required" if outcome_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id,
        :outcome_id => outcome_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_groups/{id}/outcomes/{outcome_id}",
        :course_id => course_id,
        :id => id,
        :outcome_id => outcome_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      OutcomeLink.new(response)
    end
    def unlink_outcome_global(id,outcome_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "outcome_id is required" if outcome_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :outcome_id => outcome_id
      )

      # resource path
      path = path_replace("/v1/global/outcome_groups/{id}/outcomes/{outcome_id}",
        :id => id,
        :outcome_id => outcome_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      OutcomeLink.new(response)
    end
    def unlink_outcome_accounts(account_id,id,outcome_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      raise "outcome_id is required" if outcome_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id,
        :outcome_id => outcome_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_groups/{id}/outcomes/{outcome_id}",
        :account_id => account_id,
        :id => id,
        :outcome_id => outcome_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      OutcomeLink.new(response)
    end
    def unlink_outcome_courses(course_id,id,outcome_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      raise "outcome_id is required" if outcome_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id,
        :outcome_id => outcome_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_groups/{id}/outcomes/{outcome_id}",
        :course_id => course_id,
        :id => id,
        :outcome_id => outcome_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      OutcomeLink.new(response)
    end
    def list_subgroups_global(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/global/outcome_groups/{id}/subgroups",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|OutcomeGroup.new(response)}
    end
    def list_subgroups_accounts(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_groups/{id}/subgroups",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|OutcomeGroup.new(response)}
    end
    def list_subgroups_courses(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_groups/{id}/subgroups",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|OutcomeGroup.new(response)}
    end
    def create_subgroup_global(id,title,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :description,
        :vendor_guid,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "title is required" if title.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :title => title
      )

      # resource path
      path = path_replace("/v1/global/outcome_groups/{id}/subgroups",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      OutcomeGroup.new(response)
    end
    def create_subgroup_accounts(account_id,id,title,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :description,
        :vendor_guid,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      raise "title is required" if title.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id,
        :title => title
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_groups/{id}/subgroups",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      OutcomeGroup.new(response)
    end
    def create_subgroup_courses(course_id,id,title,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :description,
        :vendor_guid,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      raise "title is required" if title.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id,
        :title => title
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_groups/{id}/subgroups",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      OutcomeGroup.new(response)
    end
    def import_outcome_group_global(id,source_outcome_group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :source_outcome_group_id,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "source_outcome_group_id is required" if source_outcome_group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :source_outcome_group_id => source_outcome_group_id
      )

      # resource path
      path = path_replace("/v1/global/outcome_groups/{id}/import",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      OutcomeGroup.new(response)
    end
    def import_outcome_group_accounts(account_id,id,source_outcome_group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :source_outcome_group_id,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      raise "source_outcome_group_id is required" if source_outcome_group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id,
        :source_outcome_group_id => source_outcome_group_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_groups/{id}/import",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      OutcomeGroup.new(response)
    end
    def import_outcome_group_courses(course_id,id,source_outcome_group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :source_outcome_group_id,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      raise "source_outcome_group_id is required" if source_outcome_group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id,
        :source_outcome_group_id => source_outcome_group_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_groups/{id}/import",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      OutcomeGroup.new(response)
    end
    def get_outcome_result_rollups(course_id,opts={})
      query_param_keys = [
        :aggregate,
        :user_ids,
        :outcome_ids
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_rollups",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def show_outcome(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/outcomes/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      Outcome.new(response)
    end
    def update_outcome(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :description,
        :vendor_guid,
        :mastery_points,
        :ratings__description__,
        :ratings__points__,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/outcomes/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      Outcome.new(response)
    end
    def show_front_page_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/front_page",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      Page.new(response)
    end
    def show_front_page_groups(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/front_page",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      Page.new(response)
    end
    def update_create_front_page_courses(course_id,wiki_page__body__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :wiki_page__title__,
        :wiki_page__body__,
        :wiki_page__hide_from_students__,
        :wiki_page__editing_roles__,
        :wiki_page__notify_of_update__,
        :wiki_page__published__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "wiki_page__body__ is required" if wiki_page__body__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :wiki_page__body__ => wiki_page__body__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/front_page",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      Page.new(response)
    end
    def update_create_front_page_groups(group_id,wiki_page__body__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :wiki_page__title__,
        :wiki_page__body__,
        :wiki_page__hide_from_students__,
        :wiki_page__editing_roles__,
        :wiki_page__notify_of_update__,
        :wiki_page__published__,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "wiki_page__body__ is required" if wiki_page__body__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :wiki_page__body__ => wiki_page__body__
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/front_page",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      Page.new(response)
    end
    def list_pages_courses(course_id,opts={})
      query_param_keys = [
        :sort,
        :order,
        :search_term,
        :published
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/pages",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Page.new(response)}
    end
    def list_pages_groups(group_id,opts={})
      query_param_keys = [
        :sort,
        :order,
        :search_term,
        :published
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/pages",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Page.new(response)}
    end
    def create_page_courses(course_id,wiki_page__title__,wiki_page__body__,wiki_page__hide_from_students__,wiki_page__notify_of_update__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :wiki_page__title__,
        :wiki_page__body__,
        :wiki_page__hide_from_students__,
        :wiki_page__editing_roles__,
        :wiki_page__notify_of_update__,
        :wiki_page__published__,
        :wiki_page__front_page__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "wiki_page__title__ is required" if wiki_page__title__.nil?
      raise "wiki_page__body__ is required" if wiki_page__body__.nil?
      raise "wiki_page__hide_from_students__ is required" if wiki_page__hide_from_students__.nil?
      raise "wiki_page__notify_of_update__ is required" if wiki_page__notify_of_update__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :wiki_page__title__ => wiki_page__title__,
        :wiki_page__body__ => wiki_page__body__,
        :wiki_page__hide_from_students__ => wiki_page__hide_from_students__,
        :wiki_page__notify_of_update__ => wiki_page__notify_of_update__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/pages",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Page.new(response)
    end
    def create_page_groups(group_id,wiki_page__title__,wiki_page__body__,wiki_page__hide_from_students__,wiki_page__notify_of_update__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :wiki_page__title__,
        :wiki_page__body__,
        :wiki_page__hide_from_students__,
        :wiki_page__editing_roles__,
        :wiki_page__notify_of_update__,
        :wiki_page__published__,
        :wiki_page__front_page__,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "wiki_page__title__ is required" if wiki_page__title__.nil?
      raise "wiki_page__body__ is required" if wiki_page__body__.nil?
      raise "wiki_page__hide_from_students__ is required" if wiki_page__hide_from_students__.nil?
      raise "wiki_page__notify_of_update__ is required" if wiki_page__notify_of_update__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :wiki_page__title__ => wiki_page__title__,
        :wiki_page__body__ => wiki_page__body__,
        :wiki_page__hide_from_students__ => wiki_page__hide_from_students__,
        :wiki_page__notify_of_update__ => wiki_page__notify_of_update__
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/pages",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Page.new(response)
    end
    def show_page_courses(course_id,url,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "url is required" if url.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :url => url
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/pages/{url}",
        :course_id => course_id,
        :url => url)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      Page.new(response)
    end
    def show_page_groups(group_id,url,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "url is required" if url.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :url => url
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/pages/{url}",
        :group_id => group_id,
        :url => url)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      Page.new(response)
    end
    def update_create_page_courses(course_id,url,wiki_page__title__,wiki_page__body__,wiki_page__hide_from_students__,wiki_page__notify_of_update__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :wiki_page__title__,
        :wiki_page__body__,
        :wiki_page__hide_from_students__,
        :wiki_page__editing_roles__,
        :wiki_page__notify_of_update__,
        :wiki_page__published__,
        :wiki_page__front_page__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "url is required" if url.nil?
      raise "wiki_page__title__ is required" if wiki_page__title__.nil?
      raise "wiki_page__body__ is required" if wiki_page__body__.nil?
      raise "wiki_page__hide_from_students__ is required" if wiki_page__hide_from_students__.nil?
      raise "wiki_page__notify_of_update__ is required" if wiki_page__notify_of_update__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :url => url,
        :wiki_page__title__ => wiki_page__title__,
        :wiki_page__body__ => wiki_page__body__,
        :wiki_page__hide_from_students__ => wiki_page__hide_from_students__,
        :wiki_page__notify_of_update__ => wiki_page__notify_of_update__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/pages/{url}",
        :course_id => course_id,
        :url => url)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      Page.new(response)
    end
    def update_create_page_groups(group_id,url,wiki_page__title__,wiki_page__body__,wiki_page__hide_from_students__,wiki_page__notify_of_update__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :wiki_page__title__,
        :wiki_page__body__,
        :wiki_page__hide_from_students__,
        :wiki_page__editing_roles__,
        :wiki_page__notify_of_update__,
        :wiki_page__published__,
        :wiki_page__front_page__,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "url is required" if url.nil?
      raise "wiki_page__title__ is required" if wiki_page__title__.nil?
      raise "wiki_page__body__ is required" if wiki_page__body__.nil?
      raise "wiki_page__hide_from_students__ is required" if wiki_page__hide_from_students__.nil?
      raise "wiki_page__notify_of_update__ is required" if wiki_page__notify_of_update__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :url => url,
        :wiki_page__title__ => wiki_page__title__,
        :wiki_page__body__ => wiki_page__body__,
        :wiki_page__hide_from_students__ => wiki_page__hide_from_students__,
        :wiki_page__notify_of_update__ => wiki_page__notify_of_update__
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/pages/{url}",
        :group_id => group_id,
        :url => url)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      Page.new(response)
    end
    def delete_page_courses(course_id,url,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "url is required" if url.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :url => url
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/pages/{url}",
        :course_id => course_id,
        :url => url)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      Page.new(response)
    end
    def delete_page_groups(group_id,url,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "url is required" if url.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :url => url
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/pages/{url}",
        :group_id => group_id,
        :url => url)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      Page.new(response)
    end
    def list_revisions_courses(course_id,url,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "url is required" if url.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :url => url
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/pages/{url}/revisions",
        :course_id => course_id,
        :url => url)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|PageRevision.new(response)}
    end
    def list_revisions_groups(group_id,url,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "url is required" if url.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :url => url
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/pages/{url}/revisions",
        :group_id => group_id,
        :url => url)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|PageRevision.new(response)}
    end
    def show_revision_courses(course_id,url,opts={})
      query_param_keys = [
        :summary
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "url is required" if url.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :url => url
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/pages/{url}/revisions/latest",
        :course_id => course_id,
        :url => url)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      PageRevision.new(response)
    end
    def show_revision_groups(group_id,url,opts={})
      query_param_keys = [
        :summary
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "url is required" if url.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :url => url
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/pages/{url}/revisions/latest",
        :group_id => group_id,
        :url => url)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      PageRevision.new(response)
    end
    def show_revision_courses(course_id,url,revision_id,opts={})
      query_param_keys = [
        :summary
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "url is required" if url.nil?
      raise "revision_id is required" if revision_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :url => url,
        :revision_id => revision_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/pages/{url}/revisions/{revision_id}",
        :course_id => course_id,
        :url => url,
        :revision_id => revision_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      PageRevision.new(response)
    end
    def show_revision_groups(group_id,url,revision_id,opts={})
      query_param_keys = [
        :summary
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "url is required" if url.nil?
      raise "revision_id is required" if revision_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :url => url,
        :revision_id => revision_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/pages/{url}/revisions/{revision_id}",
        :group_id => group_id,
        :url => url,
        :revision_id => revision_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      PageRevision.new(response)
    end
    def revert_to_revision_courses(course_id,url,revision_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "url is required" if url.nil?
      raise "revision_id is required" if revision_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :url => url,
        :revision_id => revision_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/pages/{url}/revisions/{revision_id}",
        :course_id => course_id,
        :url => url,
        :revision_id => revision_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      PageRevision.new(response)
    end
    def revert_to_revision_groups(group_id,url,revision_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "url is required" if url.nil?
      raise "revision_id is required" if revision_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :url => url,
        :revision_id => revision_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/pages/{url}/revisions/{revision_id}",
        :group_id => group_id,
        :url => url,
        :revision_id => revision_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      PageRevision.new(response)
    end
    def query_progress(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/progress/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      Progress.new(response)
    end
    def get_available_quiz_ip_filters(course_id,quiz_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/ip_filters",
        :course_id => course_id,
        :quiz_id => quiz_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def create_question_group(course_id,quiz_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :quiz_groups__name__,
        :quiz_groups__pick_count__,
        :quiz_groups__question_points__,
        :quiz_groups__assessment_question_bank_id__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/groups",
        :course_id => course_id,
        :quiz_id => quiz_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def update_question_group(course_id,quiz_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :quiz_groups__name__,
        :quiz_groups__pick_count__,
        :quiz_groups__question_points__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/groups/{id}",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def delete_question_group(course_id,quiz_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/groups/{id}",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def reorder_question_groups(course_id,quiz_id,id,order__id__,order__type__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :order__id__,
        :order__type__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      raise "order__id__ is required" if order__id__.nil?
      raise "order__type__ is required" if order__type__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id,
        :order__id__ => order__id__,
        :order__type__ => order__type__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/groups/{id}/reorder",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def create_quiz_report(course_id,quiz_id,quiz_report__report_type__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :quiz_report__report_type__,
        :quiz_report__includes_all_versions__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "quiz_report__report_type__ is required" if quiz_report__report_type__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :quiz_report__report_type__ => quiz_report__report_type__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/reports",
        :course_id => course_id,
        :quiz_id => quiz_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      QuizReport.new(response)
    end
    def get_quiz_report(course_id,quiz_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/reports/{id}",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      QuizReport.new(response)
    end
    def upload_file(course_id,quiz_id,name,on_duplicate,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :on_duplicate,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "name is required" if name.nil?
      raise "on_duplicate is required" if on_duplicate.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :name => name,
        :on_duplicate => on_duplicate
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/submissions/self/files",
        :course_id => course_id,
        :quiz_id => quiz_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def get_all_quiz_submissions(course_id,quiz_id,include,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :include => include
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/submissions",
        :course_id => course_id,
        :quiz_id => quiz_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_single_quiz_submission(course_id,quiz_id,id,include,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id,
        :include => include
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/submissions/{id}",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def create_the_quiz_submission_start_quiz_taking_session(course_id,quiz_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :access_code,
        :preview,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/submissions",
        :course_id => course_id,
        :quiz_id => quiz_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def update_student_question_scores_and_comments(course_id,quiz_id,id,attempt,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :attempt,
        :fudge_points,
        :questions,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      raise "attempt is required" if attempt.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id,
        :attempt => attempt
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/submissions/{id}",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def complete_the_quiz_submission_turn_it_in(course_id,quiz_id,id,attempt,validation_token,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :attempt,
        :validation_token,
        :access_code,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      raise "attempt is required" if attempt.nil?
      raise "validation_token is required" if validation_token.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id,
        :attempt => attempt,
        :validation_token => validation_token
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/submissions/{id}/complete",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def list_questions_in_quiz(course_id,quiz_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/questions",
        :course_id => course_id,
        :quiz_id => quiz_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|QuizQuestion.new(response)}
    end
    def get_single_quiz_question(course_id,quiz_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/questions/{id}",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      QuizQuestion.new(response)
    end
    def create_single_quiz_question(course_id,quiz_id,question__question_name__,question__question_text__,question__question_type__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :question__question_name__,
        :question__question_text__,
        :question__quiz_group_id__,
        :question__question_type__,
        :question__position__,
        :question__points_possible__,
        :question__correct_comments__,
        :question__incorrect_comments__,
        :question__neutral_comments__,
        :question__text_after_answers__,
        :question__answers__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "question__question_name__ is required" if question__question_name__.nil?
      raise "question__question_text__ is required" if question__question_text__.nil?
      raise "question__question_type__ is required" if question__question_type__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :question__question_name__ => question__question_name__,
        :question__question_text__ => question__question_text__,
        :question__question_type__ => question__question_type__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/questions",
        :course_id => course_id,
        :quiz_id => quiz_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      QuizQuestion.new(response)
    end
    def update_existing_quiz_question(course_id,quiz_id,id,question__question_name__,question__question_text__,question__question_type__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :question__question_name__,
        :question__question_text__,
        :question__quiz_group_id__,
        :question__question_type__,
        :question__position__,
        :question__points_possible__,
        :question__correct_comments__,
        :question__incorrect_comments__,
        :question__neutral_comments__,
        :question__text_after_answers__,
        :question__answers__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      raise "question__question_name__ is required" if question__question_name__.nil?
      raise "question__question_text__ is required" if question__question_text__.nil?
      raise "question__question_type__ is required" if question__question_type__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id,
        :question__question_name__ => question__question_name__,
        :question__question_text__ => question__question_text__,
        :question__question_type__ => question__question_type__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/questions/{id}",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      QuizQuestion.new(response)
    end
    def delete_quiz_question(course_id,quiz_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/questions/{id}",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def list_quizzes_in_course(course_id,opts={})
      query_param_keys = [
        :search_term
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Quiz.new(response)}
    end
    def get_single_quiz(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      Quiz.new(response)
    end
    def create_quiz(course_id,quiz__title__,quiz__description__,quiz__quiz_type__,quiz__assignment_group_id__,quiz__time_limit__,quiz__shuffle_answers__,quiz__scoring_policy__,quiz__due_at__,quiz__lock_at__,quiz__unlock_at__,quiz__published__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :quiz__title__,
        :quiz__description__,
        :quiz__quiz_type__,
        :quiz__assignment_group_id__,
        :quiz__time_limit__,
        :quiz__shuffle_answers__,
        :quiz__hide_results__,
        :quiz__show_correct_answers__,
        :quiz__show_correct_answers_at__,
        :quiz__hide_correct_answers_at__,
        :quiz__allowed_attempts__,
        :quiz__scoring_policy__,
        :quiz__one_question_at_a_time__,
        :quiz__cant_go_back__,
        :quiz__access_code__,
        :quiz__ip_filter__,
        :quiz__due_at__,
        :quiz__lock_at__,
        :quiz__unlock_at__,
        :quiz__published__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz__title__ is required" if quiz__title__.nil?
      raise "quiz__description__ is required" if quiz__description__.nil?
      raise "quiz__quiz_type__ is required" if quiz__quiz_type__.nil?
      raise "quiz__assignment_group_id__ is required" if quiz__assignment_group_id__.nil?
      raise "quiz__time_limit__ is required" if quiz__time_limit__.nil?
      raise "quiz__shuffle_answers__ is required" if quiz__shuffle_answers__.nil?
      raise "quiz__scoring_policy__ is required" if quiz__scoring_policy__.nil?
      raise "quiz__due_at__ is required" if quiz__due_at__.nil?
      raise "quiz__lock_at__ is required" if quiz__lock_at__.nil?
      raise "quiz__unlock_at__ is required" if quiz__unlock_at__.nil?
      raise "quiz__published__ is required" if quiz__published__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz__title__ => quiz__title__,
        :quiz__description__ => quiz__description__,
        :quiz__quiz_type__ => quiz__quiz_type__,
        :quiz__assignment_group_id__ => quiz__assignment_group_id__,
        :quiz__time_limit__ => quiz__time_limit__,
        :quiz__shuffle_answers__ => quiz__shuffle_answers__,
        :quiz__scoring_policy__ => quiz__scoring_policy__,
        :quiz__due_at__ => quiz__due_at__,
        :quiz__lock_at__ => quiz__lock_at__,
        :quiz__unlock_at__ => quiz__unlock_at__,
        :quiz__published__ => quiz__published__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Quiz.new(response)
    end
    def edit_quiz(course_id,id,quiz__notify_of_update__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :quiz__notify_of_update__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      raise "quiz__notify_of_update__ is required" if quiz__notify_of_update__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id,
        :quiz__notify_of_update__ => quiz__notify_of_update__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      Quiz.new(response)
    end
    def delete_quiz(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      Quiz.new(response)
    end
    def reorder_quiz_items(course_id,id,order__id__,order__type__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :order__id__,
        :order__type__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      raise "order__id__ is required" if order__id__.nil?
      raise "order__type__ is required" if order__type__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id,
        :order__id__ => order__id__,
        :order__type__ => order__type__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{id}/reorder",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def list_roles(account_id,state,opts={})
      query_param_keys = [
        :state
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "state is required" if state.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :state => state
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/roles",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Role.new(response)}
    end
    def get_single_role(account_id,role,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "role is required" if role.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :role => role
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/roles/{role}",
        :account_id => account_id,
        :role => role)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      Role.new(response)
    end
    def create_new_role(account_id,role,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :role,
        :base_role_type,
        :permissions____x_____explicit__,
        :permissions____x_____enabled__,
        :permissions____x_____locked__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "role is required" if role.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :role => role
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/roles",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Role.new(response)
    end
    def deactivate_role(account_id,role,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "role is required" if role.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :role => role
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/roles/{role}",
        :account_id => account_id,
        :role => role)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      Role.new(response)
    end
    def activate_role(account_id,role,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "role is required" if role.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :role => role
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/roles/{role}/activate",
        :account_id => account_id,
        :role => role)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Role.new(response)
    end
    def update_role(account_id,role,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :permissions____x_____explicit__,
        :permissions____x_____enabled__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "role is required" if role.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :role => role
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/roles/{role}",
        :account_id => account_id,
        :role => role)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      Role.new(response)
    end
    def get_sis_import_list(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/sis_imports",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|SisImport.new(response)}
    end
    def import_sis_data(account_id,attachment,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :import_type,
        :attachment,
        :extension,
        :batch_mode,
        :batch_mode_term_id,
        :override_sis_stickiness,
        :add_sis_stickiness,
        :clear_sis_stickiness,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "attachment is required" if attachment.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :attachment => attachment
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/sis_imports",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      SisImport.new(response)
    end
    def get_sis_import_status(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/sis_imports/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      SisImport.new(response)
    end
    def find_recipients_conversations(search,context,exclude,type,user_id,from_conversation_id,permissions,opts={})
      query_param_keys = [
        :search,
        :context,
        :exclude,
        :type,
        :user_id,
        :from_conversation_id,
        :permissions
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "search is required" if search.nil?
      raise "context is required" if context.nil?
      raise "exclude is required" if exclude.nil?
      raise "type is required" if type.nil?
      raise "user_id is required" if user_id.nil?
      raise "from_conversation_id is required" if from_conversation_id.nil?
      raise "permissions is required" if permissions.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :search => search,
        :context => context,
        :exclude => exclude,
        :type => type,
        :user_id => user_id,
        :from_conversation_id => from_conversation_id,
        :permissions => permissions
      )

      # resource path
      path = path_replace("/v1/conversations/find_recipients",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def find_recipients_search(search,context,exclude,type,user_id,from_conversation_id,permissions,opts={})
      query_param_keys = [
        :search,
        :context,
        :exclude,
        :type,
        :user_id,
        :from_conversation_id,
        :permissions
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "search is required" if search.nil?
      raise "context is required" if context.nil?
      raise "exclude is required" if exclude.nil?
      raise "type is required" if type.nil?
      raise "user_id is required" if user_id.nil?
      raise "from_conversation_id is required" if from_conversation_id.nil?
      raise "permissions is required" if permissions.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :search => search,
        :context => context,
        :exclude => exclude,
        :type => type,
        :user_id => user_id,
        :from_conversation_id => from_conversation_id,
        :permissions => permissions
      )

      # resource path
      path = path_replace("/v1/search/recipients",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_course_sections(course_id,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/sections",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|Section.new(response)}
    end
    def create_course_section(course_id,course_section__name__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :course_section__name__,
        :course_section__sis_section_id__,
        :course_section__start_at__,
        :course_section__end_at__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "course_section__name__ is required" if course_section__name__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :course_section__name__ => course_section__name__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/sections",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Section.new(response)
    end
    def cross_list_section(id,new_course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "new_course_id is required" if new_course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :new_course_id => new_course_id
      )

      # resource path
      path = path_replace("/v1/sections/{id}/crosslist/{new_course_id}",
        :id => id,
        :new_course_id => new_course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      Section.new(response)
    end
    def de_cross_list_section(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/sections/{id}/crosslist",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      Section.new(response)
    end
    def edit_section(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/sections/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      Section.new(response)
    end
    def get_section_information_courses(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/sections/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      Section.new(response)
    end
    def get_section_information_sections(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/sections/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      Section.new(response)
    end
    def delete_section(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/sections/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      Section.new(response)
    end
    def get_kaltura_config(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/services/kaltura",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def start_kaltura_session(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/services/kaltura_session",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def upload_file(course_id,assignment_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}/comments/files",
        :course_id => course_id,
        :assignment_id => assignment_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def submit_assignment_courses(course_id,assignment_id,comment__text_comment__,submission__submission_type__,submission__body__,submission__url__,submission__file_ids__,submission__media_comment_id__,submission__media_comment_type__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :comment__text_comment__,
        :submission__submission_type__,
        :submission__body__,
        :submission__url__,
        :submission__file_ids__,
        :submission__media_comment_id__,
        :submission__media_comment_type__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "comment__text_comment__ is required" if comment__text_comment__.nil?
      raise "submission__submission_type__ is required" if submission__submission_type__.nil?
      raise "submission__body__ is required" if submission__body__.nil?
      raise "submission__url__ is required" if submission__url__.nil?
      raise "submission__file_ids__ is required" if submission__file_ids__.nil?
      raise "submission__media_comment_id__ is required" if submission__media_comment_id__.nil?
      raise "submission__media_comment_type__ is required" if submission__media_comment_type__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id,
        :comment__text_comment__ => comment__text_comment__,
        :submission__submission_type__ => submission__submission_type__,
        :submission__body__ => submission__body__,
        :submission__url__ => submission__url__,
        :submission__file_ids__ => submission__file_ids__,
        :submission__media_comment_id__ => submission__media_comment_id__,
        :submission__media_comment_type__ => submission__media_comment_type__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/submissions",
        :course_id => course_id,
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def submit_assignment_sections(section_id,assignment_id,comment__text_comment__,submission__submission_type__,submission__body__,submission__url__,submission__file_ids__,submission__media_comment_id__,submission__media_comment_type__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :comment__text_comment__,
        :submission__submission_type__,
        :submission__body__,
        :submission__url__,
        :submission__file_ids__,
        :submission__media_comment_id__,
        :submission__media_comment_type__,
        
      ]

      # verify existence of params
      raise "section_id is required" if section_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "comment__text_comment__ is required" if comment__text_comment__.nil?
      raise "submission__submission_type__ is required" if submission__submission_type__.nil?
      raise "submission__body__ is required" if submission__body__.nil?
      raise "submission__url__ is required" if submission__url__.nil?
      raise "submission__file_ids__ is required" if submission__file_ids__.nil?
      raise "submission__media_comment_id__ is required" if submission__media_comment_id__.nil?
      raise "submission__media_comment_type__ is required" if submission__media_comment_type__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :section_id => section_id,
        :assignment_id => assignment_id,
        :comment__text_comment__ => comment__text_comment__,
        :submission__submission_type__ => submission__submission_type__,
        :submission__body__ => submission__body__,
        :submission__url__ => submission__url__,
        :submission__file_ids__ => submission__file_ids__,
        :submission__media_comment_id__ => submission__media_comment_id__,
        :submission__media_comment_type__ => submission__media_comment_type__
      )

      # resource path
      path = path_replace("/v1/sections/{section_id}/assignments/{assignment_id}/submissions",
        :section_id => section_id,
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def list_assignment_submissions_courses(course_id,assignment_id,include,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id,
        :include => include
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/submissions",
        :course_id => course_id,
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_assignment_submissions_sections(section_id,assignment_id,include,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "section_id is required" if section_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :section_id => section_id,
        :assignment_id => assignment_id,
        :include => include
      )

      # resource path
      path = path_replace("/v1/sections/{section_id}/assignments/{assignment_id}/submissions",
        :section_id => section_id,
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_submissions_for_multiple_assignments_courses(course_id,student_ids,assignment_ids,grouped,include,opts={})
      query_param_keys = [
        :student_ids,
        :assignment_ids,
        :grouped,
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "student_ids is required" if student_ids.nil?
      raise "assignment_ids is required" if assignment_ids.nil?
      raise "grouped is required" if grouped.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :student_ids => student_ids,
        :assignment_ids => assignment_ids,
        :grouped => grouped,
        :include => include
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/students/submissions",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_submissions_for_multiple_assignments_sections(section_id,student_ids,assignment_ids,grouped,include,opts={})
      query_param_keys = [
        :student_ids,
        :assignment_ids,
        :grouped,
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "section_id is required" if section_id.nil?
      raise "student_ids is required" if student_ids.nil?
      raise "assignment_ids is required" if assignment_ids.nil?
      raise "grouped is required" if grouped.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :section_id => section_id,
        :student_ids => student_ids,
        :assignment_ids => assignment_ids,
        :grouped => grouped,
        :include => include
      )

      # resource path
      path = path_replace("/v1/sections/{section_id}/students/submissions",
        :section_id => section_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_single_submission_courses(course_id,assignment_id,user_id,include,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "user_id is required" if user_id.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id,
        :user_id => user_id,
        :include => include
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}",
        :course_id => course_id,
        :assignment_id => assignment_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_single_submission_sections(section_id,assignment_id,user_id,include,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "section_id is required" if section_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "user_id is required" if user_id.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :section_id => section_id,
        :assignment_id => assignment_id,
        :user_id => user_id,
        :include => include
      )

      # resource path
      path = path_replace("/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}",
        :section_id => section_id,
        :assignment_id => assignment_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def upload_file_courses(course_id,assignment_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}/files",
        :course_id => course_id,
        :assignment_id => assignment_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def upload_file_sections(section_id,assignment_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "section_id is required" if section_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :section_id => section_id,
        :assignment_id => assignment_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}/files",
        :section_id => section_id,
        :assignment_id => assignment_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def grade_or_comment_on_submission_courses(course_id,assignment_id,user_id,comment__text_comment__,comment__media_comment_id__,comment__media_comment_type__,submission__posted_grade__,rubric_assessment,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :comment__text_comment__,
        :comment__group_comment__,
        :comment__media_comment_id__,
        :comment__media_comment_type__,
        :comment__file_ids__,
        :submission__posted_grade__,
        :rubric_assessment,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "user_id is required" if user_id.nil?
      raise "comment__text_comment__ is required" if comment__text_comment__.nil?
      raise "comment__media_comment_id__ is required" if comment__media_comment_id__.nil?
      raise "comment__media_comment_type__ is required" if comment__media_comment_type__.nil?
      raise "submission__posted_grade__ is required" if submission__posted_grade__.nil?
      raise "rubric_assessment is required" if rubric_assessment.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id,
        :user_id => user_id,
        :comment__text_comment__ => comment__text_comment__,
        :comment__media_comment_id__ => comment__media_comment_id__,
        :comment__media_comment_type__ => comment__media_comment_type__,
        :submission__posted_grade__ => submission__posted_grade__,
        :rubric_assessment => rubric_assessment
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}",
        :course_id => course_id,
        :assignment_id => assignment_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def grade_or_comment_on_submission_sections(section_id,assignment_id,user_id,comment__text_comment__,comment__media_comment_id__,comment__media_comment_type__,submission__posted_grade__,rubric_assessment,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :comment__text_comment__,
        :comment__group_comment__,
        :comment__media_comment_id__,
        :comment__media_comment_type__,
        :comment__file_ids__,
        :submission__posted_grade__,
        :rubric_assessment,
        
      ]

      # verify existence of params
      raise "section_id is required" if section_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "user_id is required" if user_id.nil?
      raise "comment__text_comment__ is required" if comment__text_comment__.nil?
      raise "comment__media_comment_id__ is required" if comment__media_comment_id__.nil?
      raise "comment__media_comment_type__ is required" if comment__media_comment_type__.nil?
      raise "submission__posted_grade__ is required" if submission__posted_grade__.nil?
      raise "rubric_assessment is required" if rubric_assessment.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :section_id => section_id,
        :assignment_id => assignment_id,
        :user_id => user_id,
        :comment__text_comment__ => comment__text_comment__,
        :comment__media_comment_id__ => comment__media_comment_id__,
        :comment__media_comment_type__ => comment__media_comment_type__,
        :submission__posted_grade__ => submission__posted_grade__,
        :rubric_assessment => rubric_assessment
      )

      # resource path
      path = path_replace("/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}",
        :section_id => section_id,
        :assignment_id => assignment_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def list_available_tabs_for_course_or_group_courses(course_id,include,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :include => include
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/tabs",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_available_tabs_for_course_or_group_groups(group_id,include,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "include is required" if include.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :include => include
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/tabs",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_users_in_account(account_id,opts={})
      query_param_keys = [
        :search_term
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/users",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|User.new(response)}
    end
    def list_the_activity_stream_users(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/users/self/activity_stream",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_the_activity_stream_users(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/users/activity_stream",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def activity_stream_summary(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/users/self/activity_stream/summary",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_the_todo_items(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/users/self/todo",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_upcoming_assignments_calendar_events(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/users/self/upcoming_events",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def hide_stream_item(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/users/self/activity_stream/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def hide_all_stream_items(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/users/self/activity_stream",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def upload_file(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/files",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      response
      
    end
    def create_user(account_id,pseudonym__unique_id__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :user__name__,
        :user__short_name__,
        :user__sortable_name__,
        :user__time_zone__,
        :user__locale__,
        :user__birthdate__,
        :pseudonym__unique_id__,
        :pseudonym__password__,
        :pseudonym__sis_user_id__,
        :pseudonym__send_confirmation__,
        :communication_channel__type__,
        :communication_channel__address__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "pseudonym__unique_id__ is required" if pseudonym__unique_id__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :pseudonym__unique_id__ => pseudonym__unique_id__
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/users",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:post, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:post, path, query_params, form_params, headers)
      page_params_store(:post, path)
      User.new(response)
    end
    def update_user_settings_users(id,manual_mark_as_read,opts={})
      query_param_keys = [
        :manual_mark_as_read
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "manual_mark_as_read is required" if manual_mark_as_read.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :manual_mark_as_read => manual_mark_as_read
      )

      # resource path
      path = path_replace("/v1/users/{id}/settings",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def update_user_settings_users(id,manual_mark_as_read,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :manual_mark_as_read,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "manual_mark_as_read is required" if manual_mark_as_read.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :manual_mark_as_read => manual_mark_as_read
      )

      # resource path
      path = path_replace("/v1/users/{id}/settings",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def edit_user(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :user__name__,
        :user__short_name__,
        :user__sortable_name__,
        :user__time_zone__,
        :user__locale__,
        :user__avatar____token__,
        :user__avatar____url__,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/users/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      User.new(response)
    end
    def delete_user(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/users/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      User.new(response)
    end
    def follow_user(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/followers/self",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      response
      
    end
    def un_follow_user(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/followers/self",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:delete, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:delete, path, query_params, form_params, headers)
      page_params_store(:delete, path)
      response
      
    end
    def merge_user_into_another_user_users(id,destination_user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "destination_user_id is required" if destination_user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :destination_user_id => destination_user_id
      )

      # resource path
      path = path_replace("/v1/users/{id}/merge_into/{destination_user_id}",
        :id => id,
        :destination_user_id => destination_user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      User.new(response)
    end
    def merge_user_into_another_user_users(id,destination_account_id,destination_user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "destination_account_id is required" if destination_account_id.nil?
      raise "destination_user_id is required" if destination_user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :destination_account_id => destination_account_id,
        :destination_user_id => destination_user_id
      )

      # resource path
      path = path_replace("/v1/users/{id}/merge_into/accounts/{destination_account_id}/users/{destination_user_id}",
        :id => id,
        :destination_account_id => destination_account_id,
        :destination_user_id => destination_user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:put, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:put, path, query_params, form_params, headers)
      page_params_store(:put, path)
      User.new(response)
    end
    def list_associated_root_accounts(id,opts={})
      query_param_keys = [
        :search
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/users/{id}/accounts",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def get_user_profile(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/profile",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_avatar_options(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/avatars",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response
      
    end
    def list_user_page_views(user_id,opts={})
      query_param_keys = [
        :start_time,
        :end_time
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/page_views",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_params(options, query_param_keys)
      if opts[:next_page]
        pagination_params = page_params_load(:get, path)
        query_params.merge! pagination_params if pagination_params
      end
      response = mixed_request(:get, path, query_params, form_params, headers)
      page_params_store(:get, path)
      response.map {|response|PageView.new(response)}
    end
    
  end
end

