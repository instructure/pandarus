require "pandarus/api_base"
require "pandarus/models"

# This is an autogenerated file. See readme.md
module Pandarus
  class V1 < APIBase

    self.prefix = "https://canvas.instructure.com/api"

    
    # List Authorization Configs
    def list_authorization_configs(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/account_authorization_configs",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, AccountAuthorizationConfig, path, query_params)
      
    end
    
    # Create Authorization Config
    def create_authorization_config(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/account_authorization_configs",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      AccountAuthorizationConfig.new(response)
      
    end
    
    # Update Authorization Config
    def update_authorization_config(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/account_authorization_configs/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      AccountAuthorizationConfig.new(response)
      
    end
    
    # Get Authorization Config
    def get_authorization_config(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/account_authorization_configs/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      AccountAuthorizationConfig.new(response)
      
    end
    
    # Delete Authorization Config
    def delete_authorization_config(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/account_authorization_configs/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # GET discovery url
    def get_discovery_url(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/account_authorization_configs/discovery_url",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      DiscoveryUrl.new(response)
      
    end
    
    # Set discovery url
    def set_discovery_url(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/account_authorization_configs/discovery_url",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      DiscoveryUrl.new(response)
      
    end
    
    # Delete discovery url
    def delete_discovery_url(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/account_authorization_configs/discovery_url",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Search account domains
    def search_account_domains(opts={})
      query_param_keys = [
        :name,
        :domain,
        :latitude,
        :longitude
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/accounts/search",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Index of active global notification for the user
    def index_of_active_global_notification_for_user(account_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/users/{user_id}/account_notifications",
        :account_id => account_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, AccountNotification, path, query_params)
      
    end
    
    # Close notification for user
    def close_notification_for_user(account_id,user_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "user_id is required" if user_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :user_id => user_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/users/{user_id}/account_notifications/{id}",
        :account_id => account_id,
        :user_id => user_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      AccountNotification.new(response)
      
    end
    
    # Create a global notification
    def create_global_notification(account_id,account_notification__subject__,account_notification__message__,account_notification__start_at__,account_notification__end_at__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :account_notification__subject__,
        :account_notification__message__,
        :account_notification__start_at__,
        :account_notification__end_at__,
        :account_notification__icon__,
        :account_notification_roles,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "account_notification__subject__ is required" if account_notification__subject__.nil?
      raise "account_notification__message__ is required" if account_notification__message__.nil?
      raise "account_notification__start_at__ is required" if account_notification__start_at__.nil?
      raise "account_notification__end_at__ is required" if account_notification__end_at__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :account_notification__subject__ => account_notification__subject__,
        :account_notification__message__ => account_notification__message__,
        :account_notification__start_at__ => account_notification__start_at__,
        :account_notification__end_at__ => account_notification__end_at__
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/account_notifications",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # List Available Reports
    def list_available_reports(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/reports",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Start a Report
    def start_report(account_id,report,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :__parameters__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "report is required" if report.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :report => report
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/reports/{report}",
        :account_id => account_id,
        :report => report)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Report.new(response)
      
    end
    
    # Index of Reports
    def index_of_reports(account_id,report,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "report is required" if report.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :report => report
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/reports/{report}",
        :account_id => account_id,
        :report => report)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Report, path, query_params)
      
    end
    
    # Status of a Report
    def status_of_report(account_id,report,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "report is required" if report.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :report => report,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/reports/{report}/{id}",
        :account_id => account_id,
        :report => report,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Report.new(response)
      
    end
    
    # Delete a Report
    def delete_report(account_id,report,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "report is required" if report.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :report => report,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/reports/{report}/{id}",
        :account_id => account_id,
        :report => report,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      Report.new(response)
      
    end
    
    # List accounts
    def list_accounts(opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/accounts",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Account, path, query_params)
      
    end
    
    # List accounts for course admins
    def list_accounts_for_course_admins(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/course_accounts",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Account, path, query_params)
      
    end
    
    # Get a single account
    def get_single_account(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Account.new(response)
      
    end
    
    # Get the sub-accounts of an account
    def get_sub_accounts_of_account(account_id,opts={})
      query_param_keys = [
        :recursive
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/sub_accounts",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Account, path, query_params)
      
    end
    
    # List active courses in an account
    def list_active_courses_in_account(account_id,opts={})
      query_param_keys = [
        :with_enrollments,
        :published,
        :completed,
        :by_teachers,
        :by_subaccounts,
        :hide_enrollmentless_courses,
        :state,
        :enrollment_term_id,
        :search_term,
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/courses",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Course, path, query_params)
      
    end
    
    # Update an account
    def update_account(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :account__name__,
        :account__default_time_zone__,
        :account__default_storage_quota_mb__,
        :account__default_user_storage_quota_mb__,
        :account__default_group_storage_quota_mb__,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      Account.new(response)
      
    end
    
    # Delete a user from the root account
    def delete_user_from_root_account(account_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/users/{user_id}",
        :account_id => account_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      User.new(response)
      
    end
    
    # Create a new sub-account
    def create_new_sub_account(account_id,account__name__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :account__name__,
        :account__default_storage_quota_mb__,
        :account__default_user_storage_quota_mb__,
        :account__default_group_storage_quota_mb__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "account__name__ is required" if account__name__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :account__name__ => account__name__
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/sub_accounts",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Account, path, query_params)
      
    end
    
    # Make an account admin
    def make_account_admin(account_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :user_id,
        :role,
        :role_id,
        :send_confirmation,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/admins",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Admin.new(response)
      
    end
    
    # Remove account admin
    def remove_account_admin(account_id,user_id,opts={})
      query_param_keys = [
        :role,
        :role_id
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/admins/{user_id}",
        :account_id => account_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      Admin.new(response)
      
    end
    
    # List account admins
    def list_account_admins(account_id,opts={})
      query_param_keys = [
        :user_id
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/admins",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Admin, path, query_params)
      
    end
    
    # List external feeds
    def list_external_feeds_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/external_feeds",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, ExternalFeed, path, query_params)
      
    end
    
    # List external feeds
    def list_external_feeds_groups(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/external_feeds",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, ExternalFeed, path, query_params)
      
    end
    
    # Create an external feed
    def create_external_feed_courses(course_id,url,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :url,
        :header_match,
        :verbosity,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "url is required" if url.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :url => url
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/external_feeds",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      ExternalFeed.new(response)
      
    end
    
    # Create an external feed
    def create_external_feed_groups(group_id,url,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :url,
        :header_match,
        :verbosity,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "url is required" if url.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :url => url
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/external_feeds",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      ExternalFeed.new(response)
      
    end
    
    # Delete an external feed
    def delete_external_feed_courses(course_id,external_feed_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "external_feed_id is required" if external_feed_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :external_feed_id => external_feed_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/external_feeds/{external_feed_id}",
        :course_id => course_id,
        :external_feed_id => external_feed_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      ExternalFeed.new(response)
      
    end
    
    # Delete an external feed
    def delete_external_feed_groups(group_id,external_feed_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "external_feed_id is required" if external_feed_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :external_feed_id => external_feed_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/external_feeds/{external_feed_id}",
        :group_id => group_id,
        :external_feed_id => external_feed_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      ExternalFeed.new(response)
      
    end
    
    # List appointment groups
    def list_appointment_groups(opts={})
      query_param_keys = [
        :scope,
        :context_codes,
        :include_past_appointments,
        :include
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/appointment_groups",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Create an appointment group
    def create_appointment_group(appointment_group__context_codes__,appointment_group__title__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :appointment_group__context_codes__,
        :appointment_group__sub_context_codes__,
        :appointment_group__title__,
        :appointment_group__description__,
        :appointment_group__location_name__,
        :appointment_group__location_address__,
        :appointment_group__publish__,
        :appointment_group__participants_per_appointment__,
        :appointment_group__min_appointments_per_participant__,
        :appointment_group__max_appointments_per_participant__,
        :appointment_group__new_appointments_____x__,
        :appointment_group__participant_visibility__,
        
      ]

      # verify existence of params
      raise "appointment_group__context_codes__ is required" if appointment_group__context_codes__.nil?
      raise "appointment_group__title__ is required" if appointment_group__title__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :appointment_group__context_codes__ => appointment_group__context_codes__,
        :appointment_group__title__ => appointment_group__title__
      )

      # resource path
      path = path_replace("/v1/appointment_groups",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Get a single appointment group
    def get_single_appointment_group(id,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/appointment_groups/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Update an appointment group
    def update_appointment_group(id,appointment_group__context_codes__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :appointment_group__context_codes__,
        :appointment_group__sub_context_codes__,
        :appointment_group__title__,
        :appointment_group__description__,
        :appointment_group__location_name__,
        :appointment_group__location_address__,
        :appointment_group__publish__,
        :appointment_group__participants_per_appointment__,
        :appointment_group__min_appointments_per_participant__,
        :appointment_group__max_appointments_per_participant__,
        :appointment_group__new_appointments_____x__,
        :appointment_group__participant_visibility__,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "appointment_group__context_codes__ is required" if appointment_group__context_codes__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :appointment_group__context_codes__ => appointment_group__context_codes__
      )

      # resource path
      path = path_replace("/v1/appointment_groups/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Delete an appointment group
    def delete_appointment_group(id,opts={})
      query_param_keys = [
        :cancel_reason
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/appointment_groups/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # List user participants
    def list_user_participants(id,opts={})
      query_param_keys = [
        :registration_status
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/appointment_groups/{id}/users",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List student group participants
    def list_student_group_participants(id,opts={})
      query_param_keys = [
        :registration_status
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/appointment_groups/{id}/groups",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List assignment groups
    def list_assignment_groups(course_id,opts={})
      query_param_keys = [
        :include,
        :override_assignment_dates,
        :grading_period_id
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignment_groups",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, AssignmentGroup, path, query_params)
      
    end
    
    # Get an Assignment Group
    def get_assignment_group(course_id,assignment_group_id,opts={})
      query_param_keys = [
        :include,
        :override_assignment_dates,
        :grading_period_id
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_group_id is required" if assignment_group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_group_id => assignment_group_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignment_groups/{assignment_group_id}",
        :course_id => course_id,
        :assignment_group_id => assignment_group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      AssignmentGroup.new(response)
      
    end
    
    # Create an Assignment Group
    def create_assignment_group(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :position,
        :group_weight,
        :rules,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignment_groups",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      AssignmentGroup.new(response)
      
    end
    
    # Edit an Assignment Group
    def edit_assignment_group(course_id,assignment_group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_group_id is required" if assignment_group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_group_id => assignment_group_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignment_groups/{assignment_group_id}",
        :course_id => course_id,
        :assignment_group_id => assignment_group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      AssignmentGroup.new(response)
      
    end
    
    # Destroy an Assignment Group
    def destroy_assignment_group(course_id,assignment_group_id,opts={})
      query_param_keys = [
        :move_assignment_to
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_group_id is required" if assignment_group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_group_id => assignment_group_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignment_groups/{assignment_group_id}",
        :course_id => course_id,
        :assignment_group_id => assignment_group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      AssignmentGroup.new(response)
      
    end
    
    # Delete an assignment
    def delete_assignment(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      Assignment.new(response)
      
    end
    
    # List assignments
    def list_assignments(course_id,opts={})
      query_param_keys = [
        :include,
        :search_term,
        :override_assignment_dates,
        :needs_grading_count_by_section,
        :bucket
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Assignment, path, query_params)
      
    end
    
    # Get a single assignment
    def get_single_assignment(course_id,id,opts={})
      query_param_keys = [
        :include,
        :override_assignment_dates,
        :needs_grading_count_by_section,
        :all_dates
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Assignment.new(response)
      
    end
    
    # Create an assignment
    def create_assignment(course_id,assignment__name__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :assignment__name__,
        :assignment__position__,
        :assignment__submission_types__,
        :assignment__allowed_extensions__,
        :assignment__turnitin_enabled__,
        :assignment__turnitin_settings__,
        :assignment__integration_data__,
        :assignment__integration_id__,
        :assignment__peer_reviews__,
        :assignment__automatic_peer_reviews__,
        :assignment__notify_of_update__,
        :assignment__group_category_id__,
        :assignment__grade_group_students_individually__,
        :assignment__external_tool_tag_attributes__,
        :assignment__points_possible__,
        :assignment__grading_type__,
        :assignment__due_at__,
        :assignment__lock_at__,
        :assignment__unlock_at__,
        :assignment__description__,
        :assignment__assignment_group_id__,
        :assignment__muted__,
        :assignment__assignment_overrides__,
        :assignment__only_visible_to_overrides__,
        :assignment__published__,
        :assignment__grading_standard_id__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment__name__ is required" if assignment__name__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment__name__ => assignment__name__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Assignment.new(response)
      
    end
    
    # Edit an assignment
    def edit_assignment(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :assignment__name__,
        :assignment__position__,
        :assignment__submission_types__,
        :assignment__allowed_extensions__,
        :assignment__turnitin_enabled__,
        :assignment__turnitin_settings__,
        :assignment__integration_data__,
        :assignment__integration_id__,
        :assignment__peer_reviews__,
        :assignment__automatic_peer_reviews__,
        :assignment__notify_of_update__,
        :assignment__group_category_id__,
        :assignment__grade_group_students_individually__,
        :assignment__external_tool_tag_attributes__,
        :assignment__points_possible__,
        :assignment__grading_type__,
        :assignment__due_at__,
        :assignment__lock_at__,
        :assignment__unlock_at__,
        :assignment__description__,
        :assignment__assignment_group_id__,
        :assignment__muted__,
        :assignment__assignment_overrides__,
        :assignment__only_visible_to_overrides__,
        :assignment__published__,
        :assignment__grading_standard_id__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      Assignment.new(response)
      
    end
    
    # List assignment overrides
    def list_assignment_overrides(course_id,assignment_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/overrides",
        :course_id => course_id,
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, AssignmentOverride, path, query_params)
      
    end
    
    # Get a single assignment override
    def get_single_assignment_override(course_id,assignment_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/overrides/{id}",
        :course_id => course_id,
        :assignment_id => assignment_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      AssignmentOverride.new(response)
      
    end
    
    # Redirect to the assignment override for a group
    def redirect_to_assignment_override_for_group(group_id,assignment_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :assignment_id => assignment_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/assignments/{assignment_id}/override",
        :group_id => group_id,
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Redirect to the assignment override for a section
    def redirect_to_assignment_override_for_section(course_section_id,assignment_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_section_id is required" if course_section_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_section_id => course_section_id,
        :assignment_id => assignment_id
      )

      # resource path
      path = path_replace("/v1/sections/{course_section_id}/assignments/{assignment_id}/override",
        :course_section_id => course_section_id,
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Create an assignment override
    def create_assignment_override(course_id,assignment_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :assignment_override__student_ids__,
        :assignment_override__title__,
        :assignment_override__group_id__,
        :assignment_override__course_section_id__,
        :assignment_override__due_at__,
        :assignment_override__unlock_at__,
        :assignment_override__lock_at__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/overrides",
        :course_id => course_id,
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      AssignmentOverride.new(response)
      
    end
    
    # Update an assignment override
    def update_assignment_override(course_id,assignment_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :assignment_override__student_ids__,
        :assignment_override__title__,
        :assignment_override__due_at__,
        :assignment_override__unlock_at__,
        :assignment_override__lock_at__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/overrides/{id}",
        :course_id => course_id,
        :assignment_id => assignment_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      AssignmentOverride.new(response)
      
    end
    
    # Delete an assignment override
    def delete_assignment_override(course_id,assignment_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/overrides/{id}",
        :course_id => course_id,
        :assignment_id => assignment_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      AssignmentOverride.new(response)
      
    end
    
    # Query by login.
    def query_by_login(login_id,opts={})
      query_param_keys = [
        :start_time,
        :end_time
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "login_id is required" if login_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :login_id => login_id
      )

      # resource path
      path = path_replace("/v1/audit/authentication/logins/{login_id}",
        :login_id => login_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Query by account.
    def query_by_account(account_id,opts={})
      query_param_keys = [
        :start_time,
        :end_time
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/audit/authentication/accounts/{account_id}",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Query by user.
    def query_by_user(user_id,opts={})
      query_param_keys = [
        :start_time,
        :end_time
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/audit/authentication/users/{user_id}",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List calendar events
    def list_calendar_events(opts={})
      query_param_keys = [
        :type,
        :start_date,
        :end_date,
        :undated,
        :all_events,
        :context_codes
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/calendar_events",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, CalendarEvent, path, query_params)
      
    end
    
    # Create a calendar event
    def create_calendar_event(calendar_event__context_code__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :calendar_event__context_code__,
        :calendar_event__title__,
        :calendar_event__description__,
        :calendar_event__start_at__,
        :calendar_event__end_at__,
        :calendar_event__location_name__,
        :calendar_event__location_address__,
        :calendar_event__time_zone_edited__,
        :calendar_event__child_event_data_____x____start_at__,
        :calendar_event__child_event_data_____x____end_at__,
        :calendar_event__child_event_data_____x____context_code__,
        
      ]

      # verify existence of params
      raise "calendar_event__context_code__ is required" if calendar_event__context_code__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :calendar_event__context_code__ => calendar_event__context_code__
      )

      # resource path
      path = path_replace("/v1/calendar_events",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Get a single calendar event or assignment
    def get_single_calendar_event_or_assignment(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/calendar_events/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      CalendarEvent.new(response)
      
    end
    
    # Reserve a time slot
    def reserve_time_slot(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :participant_id,
        :cancel_existing,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/calendar_events/{id}/reservations",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Reserve a time slot
    def reserve_time_slot_participant_id(id,participant_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :cancel_existing,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "participant_id is required" if participant_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :participant_id => participant_id
      )

      # resource path
      path = path_replace("/v1/calendar_events/{id}/reservations/{participant_id}",
        :id => id,
        :participant_id => participant_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Update a calendar event
    def update_calendar_event(id,calendar_event__context_code__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :calendar_event__context_code__,
        :calendar_event__title__,
        :calendar_event__description__,
        :calendar_event__start_at__,
        :calendar_event__end_at__,
        :calendar_event__location_name__,
        :calendar_event__location_address__,
        :calendar_event__time_zone_edited__,
        :calendar_event__child_event_data_____x____start_at__,
        :calendar_event__child_event_data_____x____end_at__,
        :calendar_event__child_event_data_____x____context_code__,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "calendar_event__context_code__ is required" if calendar_event__context_code__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :calendar_event__context_code__ => calendar_event__context_code__
      )

      # resource path
      path = path_replace("/v1/calendar_events/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Delete a calendar event
    def delete_calendar_event(id,opts={})
      query_param_keys = [
        :cancel_reason
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/calendar_events/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # List members of a collaboration.
    def list_members_of_collaboration(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/collaborations/{id}/members",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Collaborator, path, query_params)
      
    end
    
    # List of CommMessages for a user
    def list_of_commmessages_for_user(user_id,opts={})
      query_param_keys = [
        :user_id,
        :start_time,
        :end_time
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/comm_messages",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, CommMessage, path, query_params)
      
    end
    
    # List user communication channels
    def list_user_communication_channels(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/communication_channels",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, CommunicationChannel, path, query_params)
      
    end
    
    # Create a communication channel
    def create_communication_channel(user_id,communication_channel__address__,communication_channel__type__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :communication_channel__address__,
        :communication_channel__type__,
        :communication_channel__token__,
        :skip_confirmation,
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "communication_channel__address__ is required" if communication_channel__address__.nil?
      raise "communication_channel__type__ is required" if communication_channel__type__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :communication_channel__address__ => communication_channel__address__,
        :communication_channel__type__ => communication_channel__type__
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/communication_channels",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      CommunicationChannel.new(response)
      
    end
    
    # Delete a communication channel
    def delete_communication_channel_id(user_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/communication_channels/{id}",
        :user_id => user_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      CommunicationChannel.new(response)
      
    end
    
    # Delete a communication channel
    def delete_communication_channel_type(user_id,type,address,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "type is required" if type.nil?
      raise "address is required" if address.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :type => type,
        :address => address
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/communication_channels/{type}/{address}",
        :user_id => user_id,
        :type => type,
        :address => address)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      CommunicationChannel.new(response)
      
    end
    
    # List conferences
    def list_conferences_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/conferences",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Conference, path, query_params)
      
    end
    
    # List conferences
    def list_conferences_groups(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/conferences",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Conference, path, query_params)
      
    end
    
    # List content exports
    def list_content_exports_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_exports",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, ContentExport, path, query_params)
      
    end
    
    # List content exports
    def list_content_exports_groups(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/content_exports",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, ContentExport, path, query_params)
      
    end
    
    # List content exports
    def list_content_exports_users(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/content_exports",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, ContentExport, path, query_params)
      
    end
    
    # Show content export
    def show_content_export_courses(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_exports/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      ContentExport.new(response)
      
    end
    
    # Show content export
    def show_content_export_groups(group_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/content_exports/{id}",
        :group_id => group_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      ContentExport.new(response)
      
    end
    
    # Show content export
    def show_content_export_users(user_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/content_exports/{id}",
        :user_id => user_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      ContentExport.new(response)
      
    end
    
    # Export content
    def export_content_courses(course_id,export_type,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :export_type,
        :skip_notifications,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "export_type is required" if export_type.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :export_type => export_type
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_exports",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      ContentExport.new(response)
      
    end
    
    # Export content
    def export_content_groups(group_id,export_type,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :export_type,
        :skip_notifications,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "export_type is required" if export_type.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :export_type => export_type
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/content_exports",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      ContentExport.new(response)
      
    end
    
    # Export content
    def export_content_users(user_id,export_type,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :export_type,
        :skip_notifications,
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "export_type is required" if export_type.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :export_type => export_type
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/content_exports",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      ContentExport.new(response)
      
    end
    
    # List migration issues
    def list_migration_issues_accounts(account_id,content_migration_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "content_migration_id is required" if content_migration_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :content_migration_id => content_migration_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/content_migrations/{content_migration_id}/migration_issues",
        :account_id => account_id,
        :content_migration_id => content_migration_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, MigrationIssue, path, query_params)
      
    end
    
    # List migration issues
    def list_migration_issues_courses(course_id,content_migration_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "content_migration_id is required" if content_migration_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :content_migration_id => content_migration_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_migrations/{content_migration_id}/migration_issues",
        :course_id => course_id,
        :content_migration_id => content_migration_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, MigrationIssue, path, query_params)
      
    end
    
    # List migration issues
    def list_migration_issues_groups(group_id,content_migration_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "content_migration_id is required" if content_migration_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :content_migration_id => content_migration_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/content_migrations/{content_migration_id}/migration_issues",
        :group_id => group_id,
        :content_migration_id => content_migration_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, MigrationIssue, path, query_params)
      
    end
    
    # List migration issues
    def list_migration_issues_users(user_id,content_migration_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "content_migration_id is required" if content_migration_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :content_migration_id => content_migration_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/content_migrations/{content_migration_id}/migration_issues",
        :user_id => user_id,
        :content_migration_id => content_migration_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, MigrationIssue, path, query_params)
      
    end
    
    # Get a migration issue
    def get_migration_issue_accounts(account_id,content_migration_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "content_migration_id is required" if content_migration_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :content_migration_id => content_migration_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/content_migrations/{content_migration_id}/migration_issues/{id}",
        :account_id => account_id,
        :content_migration_id => content_migration_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      MigrationIssue.new(response)
      
    end
    
    # Get a migration issue
    def get_migration_issue_courses(course_id,content_migration_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "content_migration_id is required" if content_migration_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :content_migration_id => content_migration_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_migrations/{content_migration_id}/migration_issues/{id}",
        :course_id => course_id,
        :content_migration_id => content_migration_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      MigrationIssue.new(response)
      
    end
    
    # Get a migration issue
    def get_migration_issue_groups(group_id,content_migration_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "content_migration_id is required" if content_migration_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :content_migration_id => content_migration_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/content_migrations/{content_migration_id}/migration_issues/{id}",
        :group_id => group_id,
        :content_migration_id => content_migration_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      MigrationIssue.new(response)
      
    end
    
    # Get a migration issue
    def get_migration_issue_users(user_id,content_migration_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "content_migration_id is required" if content_migration_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :content_migration_id => content_migration_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/content_migrations/{content_migration_id}/migration_issues/{id}",
        :user_id => user_id,
        :content_migration_id => content_migration_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      MigrationIssue.new(response)
      
    end
    
    # Update a migration issue
    def update_migration_issue_accounts(account_id,content_migration_id,id,workflow_state,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :workflow_state,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "content_migration_id is required" if content_migration_id.nil?
      raise "id is required" if id.nil?
      raise "workflow_state is required" if workflow_state.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :content_migration_id => content_migration_id,
        :id => id,
        :workflow_state => workflow_state
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/content_migrations/{content_migration_id}/migration_issues/{id}",
        :account_id => account_id,
        :content_migration_id => content_migration_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      MigrationIssue.new(response)
      
    end
    
    # Update a migration issue
    def update_migration_issue_courses(course_id,content_migration_id,id,workflow_state,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :workflow_state,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "content_migration_id is required" if content_migration_id.nil?
      raise "id is required" if id.nil?
      raise "workflow_state is required" if workflow_state.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :content_migration_id => content_migration_id,
        :id => id,
        :workflow_state => workflow_state
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_migrations/{content_migration_id}/migration_issues/{id}",
        :course_id => course_id,
        :content_migration_id => content_migration_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      MigrationIssue.new(response)
      
    end
    
    # Update a migration issue
    def update_migration_issue_groups(group_id,content_migration_id,id,workflow_state,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :workflow_state,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "content_migration_id is required" if content_migration_id.nil?
      raise "id is required" if id.nil?
      raise "workflow_state is required" if workflow_state.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :content_migration_id => content_migration_id,
        :id => id,
        :workflow_state => workflow_state
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/content_migrations/{content_migration_id}/migration_issues/{id}",
        :group_id => group_id,
        :content_migration_id => content_migration_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      MigrationIssue.new(response)
      
    end
    
    # Update a migration issue
    def update_migration_issue_users(user_id,content_migration_id,id,workflow_state,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :workflow_state,
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "content_migration_id is required" if content_migration_id.nil?
      raise "id is required" if id.nil?
      raise "workflow_state is required" if workflow_state.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :content_migration_id => content_migration_id,
        :id => id,
        :workflow_state => workflow_state
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/content_migrations/{content_migration_id}/migration_issues/{id}",
        :user_id => user_id,
        :content_migration_id => content_migration_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      MigrationIssue.new(response)
      
    end
    
    # List content migrations
    def list_content_migrations_accounts(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/content_migrations",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, ContentMigration, path, query_params)
      
    end
    
    # List content migrations
    def list_content_migrations_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_migrations",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, ContentMigration, path, query_params)
      
    end
    
    # List content migrations
    def list_content_migrations_groups(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/content_migrations",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, ContentMigration, path, query_params)
      
    end
    
    # List content migrations
    def list_content_migrations_users(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/content_migrations",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, ContentMigration, path, query_params)
      
    end
    
    # Get a content migration
    def get_content_migration_accounts(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/content_migrations/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      ContentMigration.new(response)
      
    end
    
    # Get a content migration
    def get_content_migration_courses(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_migrations/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      ContentMigration.new(response)
      
    end
    
    # Get a content migration
    def get_content_migration_groups(group_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/content_migrations/{id}",
        :group_id => group_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      ContentMigration.new(response)
      
    end
    
    # Get a content migration
    def get_content_migration_users(user_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/content_migrations/{id}",
        :user_id => user_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      ContentMigration.new(response)
      
    end
    
    # Create a content migration
    def create_content_migration_accounts(account_id,migration_type,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :migration_type,
        :pre_attachment__name__,
        :pre_attachment__x__,
        :settings__file_url__,
        :settings__source_course_id__,
        :settings__folder_id__,
        :settings__overwrite_quizzes__,
        :settings__question_bank_id__,
        :settings__question_bank_name__,
        :date_shift_options__shift_dates__,
        :date_shift_options__old_start_date__,
        :date_shift_options__old_end_date__,
        :date_shift_options__new_start_date__,
        :date_shift_options__new_end_date__,
        :date_shift_options__day_substitutions_____x__,
        :date_shift_options__remove_dates__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "migration_type is required" if migration_type.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :migration_type => migration_type
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/content_migrations",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      ContentMigration.new(response)
      
    end
    
    # Create a content migration
    def create_content_migration_courses(course_id,migration_type,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :migration_type,
        :pre_attachment__name__,
        :pre_attachment__x__,
        :settings__file_url__,
        :settings__source_course_id__,
        :settings__folder_id__,
        :settings__overwrite_quizzes__,
        :settings__question_bank_id__,
        :settings__question_bank_name__,
        :date_shift_options__shift_dates__,
        :date_shift_options__old_start_date__,
        :date_shift_options__old_end_date__,
        :date_shift_options__new_start_date__,
        :date_shift_options__new_end_date__,
        :date_shift_options__day_substitutions_____x__,
        :date_shift_options__remove_dates__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "migration_type is required" if migration_type.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :migration_type => migration_type
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_migrations",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      ContentMigration.new(response)
      
    end
    
    # Create a content migration
    def create_content_migration_groups(group_id,migration_type,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :migration_type,
        :pre_attachment__name__,
        :pre_attachment__x__,
        :settings__file_url__,
        :settings__source_course_id__,
        :settings__folder_id__,
        :settings__overwrite_quizzes__,
        :settings__question_bank_id__,
        :settings__question_bank_name__,
        :date_shift_options__shift_dates__,
        :date_shift_options__old_start_date__,
        :date_shift_options__old_end_date__,
        :date_shift_options__new_start_date__,
        :date_shift_options__new_end_date__,
        :date_shift_options__day_substitutions_____x__,
        :date_shift_options__remove_dates__,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "migration_type is required" if migration_type.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :migration_type => migration_type
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/content_migrations",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      ContentMigration.new(response)
      
    end
    
    # Create a content migration
    def create_content_migration_users(user_id,migration_type,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :migration_type,
        :pre_attachment__name__,
        :pre_attachment__x__,
        :settings__file_url__,
        :settings__source_course_id__,
        :settings__folder_id__,
        :settings__overwrite_quizzes__,
        :settings__question_bank_id__,
        :settings__question_bank_name__,
        :date_shift_options__shift_dates__,
        :date_shift_options__old_start_date__,
        :date_shift_options__old_end_date__,
        :date_shift_options__new_start_date__,
        :date_shift_options__new_end_date__,
        :date_shift_options__day_substitutions_____x__,
        :date_shift_options__remove_dates__,
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "migration_type is required" if migration_type.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :migration_type => migration_type
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/content_migrations",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      ContentMigration.new(response)
      
    end
    
    # Update a content migration
    def update_content_migration_accounts(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/content_migrations/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      ContentMigration.new(response)
      
    end
    
    # Update a content migration
    def update_content_migration_courses(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_migrations/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      ContentMigration.new(response)
      
    end
    
    # Update a content migration
    def update_content_migration_groups(group_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/content_migrations/{id}",
        :group_id => group_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      ContentMigration.new(response)
      
    end
    
    # Update a content migration
    def update_content_migration_users(user_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/content_migrations/{id}",
        :user_id => user_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      ContentMigration.new(response)
      
    end
    
    # List Migration Systems
    def list_migration_systems_accounts(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/content_migrations/migrators",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Migrator, path, query_params)
      
    end
    
    # List Migration Systems
    def list_migration_systems_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_migrations/migrators",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Migrator, path, query_params)
      
    end
    
    # List Migration Systems
    def list_migration_systems_groups(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/content_migrations/migrators",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Migrator, path, query_params)
      
    end
    
    # List Migration Systems
    def list_migration_systems_users(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/content_migrations/migrators",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Migrator, path, query_params)
      
    end
    
    # List conversations
    def list_conversations(opts={})
      query_param_keys = [
        :scope,
        :filter,
        :filter_mode,
        :interleave_submissions,
        :include_all_conversation_ids
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/conversations",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Conversation, path, query_params)
      
    end
    
    # Create a conversation
    def create_conversation(recipients,body,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :recipients,
        :subject,
        :body,
        :group_conversation,
        :attachment_ids,
        :media_comment_id,
        :media_comment_type,
        :user_note,
        :mode,
        :scope,
        :filter,
        :filter_mode,
        :context_code,
        
      ]

      # verify existence of params
      raise "recipients is required" if recipients.nil?
      raise "body is required" if body.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :recipients => recipients,
        :body => body
      )

      # resource path
      path = path_replace("/v1/conversations",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Get running batches
    def get_running_batches(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/conversations/batches",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get a single conversation
    def get_single_conversation(id,opts={})
      query_param_keys = [
        :interleave_submissions,
        :scope,
        :filter,
        :filter_mode,
        :auto_mark_as_read
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/conversations/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Edit a conversation
    def edit_conversation(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :conversation__subject__,
        :conversation__workflow_state__,
        :conversation__subscribed__,
        :conversation__starred__,
        :scope,
        :filter,
        :filter_mode,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/conversations/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Mark all as read
    def mark_all_as_read(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/conversations/mark_all_as_read",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Delete a conversation
    def delete_conversation(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/conversations/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Add recipients
    def add_recipients(id,recipients,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :recipients,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "recipients is required" if recipients.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :recipients => recipients
      )

      # resource path
      path = path_replace("/v1/conversations/{id}/add_recipients",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Add a message
    def add_message(id,body,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :body,
        :attachment_ids,
        :media_comment_id,
        :media_comment_type,
        :recipients,
        :included_messages,
        :user_note,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "body is required" if body.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :body => body
      )

      # resource path
      path = path_replace("/v1/conversations/{id}/add_message",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Delete a message
    def delete_message(id,remove,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :remove,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "remove is required" if remove.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :remove => remove
      )

      # resource path
      path = path_replace("/v1/conversations/{id}/remove_messages",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Batch update conversations
    def batch_update_conversations(conversation_ids,event,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :conversation_ids,
        :event,
        
      ]

      # verify existence of params
      raise "conversation_ids is required" if conversation_ids.nil?
      raise "event is required" if event.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :conversation_ids => conversation_ids,
        :event => event
      )

      # resource path
      path = path_replace("/v1/conversations",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      Progress.new(response)
      
    end
    
    # Find recipients
    def find_recipients(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/conversations/find_recipients",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Unread count
    def unread_count(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/conversations/unread_count",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Query by course.
    def query_by_course(course_id,opts={})
      query_param_keys = [
        :start_time,
        :end_time
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/audit/course/courses/{course_id}",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, CourseEvent, path, query_params)
      
    end
    
    # Set extensions for student quiz submissions
    def set_extensions_for_student_quiz_submissions(course_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :user_id,
        :extra_attempts,
        :extra_time,
        :manually_unlocked,
        :extend_from_now,
        :extend_from_end_at,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quiz_extensions",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # List your courses
    def list_your_courses(opts={})
      query_param_keys = [
        :enrollment_type,
        :enrollment_role,
        :enrollment_role_id,
        :include,
        :state
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/courses",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Course, path, query_params)
      
    end
    
    # Create a new course
    def create_new_course(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :course__name__,
        :course__course_code__,
        :course__start_at__,
        :course__end_at__,
        :course__license__,
        :course__is_public__,
        :course__is_public_to_auth_users__,
        :course__public_syllabus__,
        :course__public_description__,
        :course__allow_student_wiki_edits__,
        :course__allow_wiki_comments__,
        :course__allow_student_forum_attachments__,
        :course__open_enrollment__,
        :course__self_enrollment__,
        :course__restrict_enrollments_to_course_dates__,
        :course__term_id__,
        :course__sis_course_id__,
        :course__integration_id__,
        :course__hide_final_grades__,
        :course__apply_assignment_group_weights__,
        :offer,
        :enroll_me,
        :course__syllabus_body__,
        :course__grading_standard_id__,
        :course__course_format__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/courses",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Course.new(response)
      
    end
    
    # Upload a file
    def upload_file(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/files",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # List students
    def list_students(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/students",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, User, path, query_params)
      
    end
    
    # List users in course
    def list_users_in_course_users(course_id,opts={})
      query_param_keys = [
        :search_term,
        :enrollment_type,
        :enrollment_role,
        :enrollment_role_id,
        :include,
        :user_id,
        :enrollment_state
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/users",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, User, path, query_params)
      
    end
    
    # List users in course
    def list_users_in_course_search_users(course_id,opts={})
      query_param_keys = [
        :search_term,
        :enrollment_type,
        :enrollment_role,
        :enrollment_role_id,
        :include,
        :user_id,
        :enrollment_state
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/search_users",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, User, path, query_params)
      
    end
    
    # List recently logged in students
    def list_recently_logged_in_students(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/recent_students",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, User, path, query_params)
      
    end
    
    # Get single user
    def get_single_user(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/users/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      User.new(response)
      
    end
    
    # Preview processed html
    def preview_processed_html(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :html,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/preview_html",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Course activity stream
    def course_activity_stream(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/activity_stream",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Course activity stream summary
    def course_activity_stream_summary(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/activity_stream/summary",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Course TODO items
    def course_todo_items(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/todo",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Conclude a course
    def conclude_course(id,event,opts={})
      query_param_keys = [
        :event
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "event is required" if event.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :event => event
      )

      # resource path
      path = path_replace("/v1/courses/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Get course settings
    def get_course_settings(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/settings",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Update course settings
    def update_course_settings(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :allow_student_discussion_topics,
        :allow_student_forum_attachments,
        :allow_student_discussion_editing,
        :allow_student_organized_groups,
        :hide_final_grades,
        :hide_distribution_graphs,
        :lock_all_announcements,
        :restrict_student_past_view,
        :restrict_student_future_view,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/settings",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Get a single course
    def get_single_course_courses(id,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Course.new(response)
      
    end
    
    # Get a single course
    def get_single_course_accounts(account_id,id,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/courses/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Course.new(response)
      
    end
    
    # Update a course
    def update_course(id,course__account_id__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :course__account_id__,
        :course__name__,
        :course__course_code__,
        :course__start_at__,
        :course__end_at__,
        :course__license__,
        :course__is_public__,
        :course__public_syllabus__,
        :course__public_description__,
        :course__allow_student_wiki_edits__,
        :course__allow_wiki_comments__,
        :course__allow_student_forum_attachments__,
        :course__open_enrollment__,
        :course__self_enrollment__,
        :course__restrict_enrollments_to_course_dates__,
        :course__term_id__,
        :course__sis_course_id__,
        :course__integration_id__,
        :course__hide_final_grades__,
        :course__apply_assignment_group_weights__,
        :offer,
        :course__syllabus_body__,
        :course__grading_standard_id__,
        :course__course_format__,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "course__account_id__ is required" if course__account_id__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :course__account_id__ => course__account_id__
      )

      # resource path
      path = path_replace("/v1/courses/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Update courses
    def update_courses(account_id,course_ids,event,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :course_ids,
        :event,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "course_ids is required" if course_ids.nil?
      raise "event is required" if event.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :course_ids => course_ids,
        :event => event
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/courses",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      Progress.new(response)
      
    end
    
    # Reset a course
    def reset_course(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/reset_content",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Course.new(response)
      
    end
    
    # Get course copy status
    def get_course_copy_status(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/course_copy/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Copy course content
    def copy_course_content(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :source_course,
        :except,
        :only,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/course_copy",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # List custom gradebook columns
    def list_custom_gradebook_columns(course_id,opts={})
      query_param_keys = [
        :include_hidden
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/custom_gradebook_columns",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, CustomColumn, path, query_params)
      
    end
    
    # Create a custom gradebook column
    def create_custom_gradebook_column(course_id,column__title__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :column__title__,
        :column__position__,
        :column__hidden__,
        :column__teacher_notes__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "column__title__ is required" if column__title__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :column__title__ => column__title__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/custom_gradebook_columns",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      CustomColumn.new(response)
      
    end
    
    # Update a custom gradebook column
    def update_custom_gradebook_column(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/custom_gradebook_columns/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      CustomColumn.new(response)
      
    end
    
    # Delete a custom gradebook column
    def delete_custom_gradebook_column(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/custom_gradebook_columns/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      CustomColumn.new(response)
      
    end
    
    # Reorder custom columns
    def reorder_custom_columns(course_id,order,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :order,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "order is required" if order.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :order => order
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/custom_gradebook_columns/reorder",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # List entries for a column
    def list_entries_for_column(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/custom_gradebook_columns/{id}/data",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, ColumnDatum, path, query_params)
      
    end
    
    # Update column data
    def update_column_data(course_id,id,user_id,column_data__content__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :column_data__content__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      raise "user_id is required" if user_id.nil?
      raise "column_data__content__ is required" if column_data__content__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id,
        :user_id => user_id,
        :column_data__content__ => column_data__content__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/custom_gradebook_columns/{id}/data/{user_id}",
        :course_id => course_id,
        :id => id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      ColumnDatum.new(response)
      
    end
    
    # List discussion topics
    def list_discussion_topics_courses(course_id,opts={})
      query_param_keys = [
        :order_by,
        :scope,
        :only_announcements,
        :search_term
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, DiscussionTopic, path, query_params)
      
    end
    
    # List discussion topics
    def list_discussion_topics_groups(group_id,opts={})
      query_param_keys = [
        :order_by,
        :scope,
        :only_announcements,
        :search_term
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, DiscussionTopic, path, query_params)
      
    end
    
    # Create a new discussion topic
    def create_new_discussion_topic_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :message,
        :discussion_type,
        :published,
        :delayed_post_at,
        :lock_at,
        :podcast_enabled,
        :podcast_has_student_posts,
        :require_initial_post,
        :assignment,
        :is_announcement,
        :position_after,
        :group_category_id,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Create a new discussion topic
    def create_new_discussion_topic_groups(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :message,
        :discussion_type,
        :published,
        :delayed_post_at,
        :lock_at,
        :podcast_enabled,
        :podcast_has_student_posts,
        :require_initial_post,
        :assignment,
        :is_announcement,
        :position_after,
        :group_category_id,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Update a topic
    def update_topic_courses(course_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :message,
        :discussion_type,
        :published,
        :delayed_post_at,
        :lock_at,
        :podcast_enabled,
        :podcast_has_student_posts,
        :require_initial_post,
        :assignment,
        :is_announcement,
        :position_after,
        :group_category_id,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Update a topic
    def update_topic_groups(group_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :message,
        :discussion_type,
        :published,
        :delayed_post_at,
        :lock_at,
        :podcast_enabled,
        :podcast_has_student_posts,
        :require_initial_post,
        :assignment,
        :is_announcement,
        :position_after,
        :group_category_id,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Delete a topic
    def delete_topic_courses(course_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Delete a topic
    def delete_topic_groups(group_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Reorder pinned topics
    def reorder_pinned_topics_courses(course_id,order,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :order,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "order is required" if order.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :order => order
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/reorder",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Reorder pinned topics
    def reorder_pinned_topics_groups(group_id,order,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :order,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "order is required" if order.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :order => order
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/reorder",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Update an entry
    def update_entry_courses(course_id,topic_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :message,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{id}",
        :course_id => course_id,
        :topic_id => topic_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Update an entry
    def update_entry_groups(group_id,topic_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :message,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{id}",
        :group_id => group_id,
        :topic_id => topic_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Delete an entry
    def delete_entry_courses(course_id,topic_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{id}",
        :course_id => course_id,
        :topic_id => topic_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Delete an entry
    def delete_entry_groups(group_id,topic_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{id}",
        :group_id => group_id,
        :topic_id => topic_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Get a single topic
    def get_single_topic_courses(course_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get a single topic
    def get_single_topic_groups(group_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get the full topic
    def get_full_topic_courses(course_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/view",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get the full topic
    def get_full_topic_groups(group_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/view",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Post an entry
    def post_entry_courses(course_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :message,
        :attachment,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/entries",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Post an entry
    def post_entry_groups(group_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :message,
        :attachment,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/entries",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # List topic entries
    def list_topic_entries_courses(course_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/entries",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List topic entries
    def list_topic_entries_groups(group_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/entries",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Post a reply
    def post_reply_courses(course_id,topic_id,entry_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :message,
        :attachment,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "entry_id is required" if entry_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id,
        :entry_id => entry_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies",
        :course_id => course_id,
        :topic_id => topic_id,
        :entry_id => entry_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Post a reply
    def post_reply_groups(group_id,topic_id,entry_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :message,
        :attachment,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "entry_id is required" if entry_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id,
        :entry_id => entry_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies",
        :group_id => group_id,
        :topic_id => topic_id,
        :entry_id => entry_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # List entry replies
    def list_entry_replies_courses(course_id,topic_id,entry_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "entry_id is required" if entry_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id,
        :entry_id => entry_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies",
        :course_id => course_id,
        :topic_id => topic_id,
        :entry_id => entry_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List entry replies
    def list_entry_replies_groups(group_id,topic_id,entry_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "entry_id is required" if entry_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id,
        :entry_id => entry_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/replies",
        :group_id => group_id,
        :topic_id => topic_id,
        :entry_id => entry_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List entries
    def list_entries_courses(course_id,topic_id,opts={})
      query_param_keys = [
        :ids
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/entry_list",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List entries
    def list_entries_groups(group_id,topic_id,opts={})
      query_param_keys = [
        :ids
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/entry_list",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Mark topic as read
    def mark_topic_as_read_courses(course_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/read",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Mark topic as read
    def mark_topic_as_read_groups(group_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/read",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Mark topic as unread
    def mark_topic_as_unread_courses(course_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/read",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Mark topic as unread
    def mark_topic_as_unread_groups(group_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/read",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Mark all entries as read
    def mark_all_entries_as_read_courses(course_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :forced_read_state,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/read_all",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Mark all entries as read
    def mark_all_entries_as_read_groups(group_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :forced_read_state,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/read_all",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Mark all entries as unread
    def mark_all_entries_as_unread_courses(course_id,topic_id,opts={})
      query_param_keys = [
        :forced_read_state
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/read_all",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Mark all entries as unread
    def mark_all_entries_as_unread_groups(group_id,topic_id,opts={})
      query_param_keys = [
        :forced_read_state
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/read_all",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Mark entry as read
    def mark_entry_as_read_courses(course_id,topic_id,entry_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :forced_read_state,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "entry_id is required" if entry_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id,
        :entry_id => entry_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/read",
        :course_id => course_id,
        :topic_id => topic_id,
        :entry_id => entry_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Mark entry as read
    def mark_entry_as_read_groups(group_id,topic_id,entry_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :forced_read_state,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "entry_id is required" if entry_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id,
        :entry_id => entry_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/read",
        :group_id => group_id,
        :topic_id => topic_id,
        :entry_id => entry_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Mark entry as unread
    def mark_entry_as_unread_courses(course_id,topic_id,entry_id,opts={})
      query_param_keys = [
        :forced_read_state
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "entry_id is required" if entry_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id,
        :entry_id => entry_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/entries/{entry_id}/read",
        :course_id => course_id,
        :topic_id => topic_id,
        :entry_id => entry_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Mark entry as unread
    def mark_entry_as_unread_groups(group_id,topic_id,entry_id,opts={})
      query_param_keys = [
        :forced_read_state
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      raise "entry_id is required" if entry_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id,
        :entry_id => entry_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/entries/{entry_id}/read",
        :group_id => group_id,
        :topic_id => topic_id,
        :entry_id => entry_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Subscribe to a topic
    def subscribe_to_topic_courses(course_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/subscribed",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Subscribe to a topic
    def subscribe_to_topic_groups(group_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/subscribed",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Unsubscribe from a topic
    def unsubscribe_from_topic_courses(course_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/discussion_topics/{topic_id}/subscribed",
        :course_id => course_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Unsubscribe from a topic
    def unsubscribe_from_topic_groups(group_id,topic_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "topic_id is required" if topic_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :topic_id => topic_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/discussion_topics/{topic_id}/subscribed",
        :group_id => group_id,
        :topic_id => topic_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Create enrollment term
    def create_enrollment_term(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :enrollment_term__name__,
        :enrollment_term__start_at__,
        :enrollment_term__end_at__,
        :enrollment_term__sis_term_id__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/terms",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      EnrollmentTerm.new(response)
      
    end
    
    # Update enrollment term
    def update_enrollment_term(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :enrollment_term__name__,
        :enrollment_term__start_at__,
        :enrollment_term__end_at__,
        :enrollment_term__sis_term_id__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/terms/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      EnrollmentTerm.new(response)
      
    end
    
    # Delete enrollment term
    def delete_enrollment_term(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/terms/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      EnrollmentTerm.new(response)
      
    end
    
    # List enrollment terms
    def list_enrollment_terms(account_id,opts={})
      query_param_keys = [
        :workflow_state
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/terms",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, EnrollmentTerm, path, query_params)
      
    end
    
    # List enrollments
    def list_enrollments_courses(course_id,opts={})
      query_param_keys = [
        :type,
        :role,
        :state,
        :user_id
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/enrollments",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Enrollment, path, query_params)
      
    end
    
    # List enrollments
    def list_enrollments_sections(section_id,opts={})
      query_param_keys = [
        :type,
        :role,
        :state,
        :user_id
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "section_id is required" if section_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :section_id => section_id
      )

      # resource path
      path = path_replace("/v1/sections/{section_id}/enrollments",
        :section_id => section_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Enrollment, path, query_params)
      
    end
    
    # List enrollments
    def list_enrollments_users(user_id,opts={})
      query_param_keys = [
        :type,
        :role,
        :state
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/enrollments",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Enrollment, path, query_params)
      
    end
    
    # Enrollment by ID
    def enrollment_by_id(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/enrollments/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Enrollment.new(response)
      
    end
    
    # Enroll a user
    def enroll_user_courses(course_id,enrollment__user_id__,enrollment__type__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :enrollment__user_id__,
        :enrollment__type__,
        :enrollment__role__,
        :enrollment__role_id__,
        :enrollment__enrollment_state__,
        :enrollment__course_section_id__,
        :enrollment__limit_privileges_to_course_section__,
        :enrollment__notify__,
        :enrollment__self_enrollment_code__,
        :enrollment__self_enrolled__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "enrollment__user_id__ is required" if enrollment__user_id__.nil?
      raise "enrollment__type__ is required" if enrollment__type__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :enrollment__user_id__ => enrollment__user_id__,
        :enrollment__type__ => enrollment__type__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/enrollments",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Enrollment.new(response)
      
    end
    
    # Enroll a user
    def enroll_user_sections(section_id,enrollment__user_id__,enrollment__type__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :enrollment__user_id__,
        :enrollment__type__,
        :enrollment__role__,
        :enrollment__role_id__,
        :enrollment__enrollment_state__,
        :enrollment__course_section_id__,
        :enrollment__limit_privileges_to_course_section__,
        :enrollment__notify__,
        :enrollment__self_enrollment_code__,
        :enrollment__self_enrolled__,
        
      ]

      # verify existence of params
      raise "section_id is required" if section_id.nil?
      raise "enrollment__user_id__ is required" if enrollment__user_id__.nil?
      raise "enrollment__type__ is required" if enrollment__type__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :section_id => section_id,
        :enrollment__user_id__ => enrollment__user_id__,
        :enrollment__type__ => enrollment__type__
      )

      # resource path
      path = path_replace("/v1/sections/{section_id}/enrollments",
        :section_id => section_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Enrollment.new(response)
      
    end
    
    # Conclude an enrollment
    def conclude_enrollment(course_id,id,opts={})
      query_param_keys = [
        :task
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/enrollments/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      Enrollment.new(response)
      
    end
    
    # List external tools
    def list_external_tools_courses(course_id,opts={})
      query_param_keys = [
        :search_term,
        :selectable
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/external_tools",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List external tools
    def list_external_tools_accounts(account_id,opts={})
      query_param_keys = [
        :search_term,
        :selectable
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/external_tools",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get a sessionless launch url for an external tool.
    def get_sessionless_launch_url_for_external_tool_courses(course_id,opts={})
      query_param_keys = [
        :id,
        :url,
        :assignment_id,
        :launch_type
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/external_tools/sessionless_launch",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get a sessionless launch url for an external tool.
    def get_sessionless_launch_url_for_external_tool_accounts(account_id,opts={})
      query_param_keys = [
        :id,
        :url,
        :assignment_id,
        :launch_type
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/external_tools/sessionless_launch",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get a single external tool
    def get_single_external_tool_courses(course_id,external_tool_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "external_tool_id is required" if external_tool_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :external_tool_id => external_tool_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/external_tools/{external_tool_id}",
        :course_id => course_id,
        :external_tool_id => external_tool_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get a single external tool
    def get_single_external_tool_accounts(account_id,external_tool_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "external_tool_id is required" if external_tool_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :external_tool_id => external_tool_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/external_tools/{external_tool_id}",
        :account_id => account_id,
        :external_tool_id => external_tool_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Create an external tool
    def create_external_tool_courses(course_id,name,privacy_level,consumer_key,shared_secret,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :privacy_level,
        :consumer_key,
        :shared_secret,
        :description,
        :url,
        :domain,
        :icon_url,
        :text,
        :not_selectable,
        :custom_fields,
        :account_navigation__url__,
        :account_navigation__enabled__,
        :account_navigation__text__,
        :user_navigation__url__,
        :user_navigation__enabled__,
        :user_navigation__text__,
        :course_navigation__url__,
        :course_navigation__enabled__,
        :course_navigation__text__,
        :course_navigation__visibility__,
        :course_navigation__default__,
        :editor_button__url__,
        :editor_button__enabled__,
        :editor_button__icon_url__,
        :editor_button__selection_width__,
        :editor_button__selection_height__,
        :resource_selection__url__,
        :resource_selection__enabled__,
        :resource_selection__icon_url__,
        :resource_selection__selection_width__,
        :resource_selection__selection_height__,
        :config_type,
        :config_xml,
        :config_url,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "name is required" if name.nil?
      raise "privacy_level is required" if privacy_level.nil?
      raise "consumer_key is required" if consumer_key.nil?
      raise "shared_secret is required" if shared_secret.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :name => name,
        :privacy_level => privacy_level,
        :consumer_key => consumer_key,
        :shared_secret => shared_secret
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/external_tools",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Create an external tool
    def create_external_tool_accounts(account_id,name,privacy_level,consumer_key,shared_secret,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :privacy_level,
        :consumer_key,
        :shared_secret,
        :description,
        :url,
        :domain,
        :icon_url,
        :text,
        :not_selectable,
        :custom_fields,
        :account_navigation__url__,
        :account_navigation__enabled__,
        :account_navigation__text__,
        :user_navigation__url__,
        :user_navigation__enabled__,
        :user_navigation__text__,
        :course_navigation__url__,
        :course_navigation__enabled__,
        :course_navigation__text__,
        :course_navigation__visibility__,
        :course_navigation__default__,
        :editor_button__url__,
        :editor_button__enabled__,
        :editor_button__icon_url__,
        :editor_button__selection_width__,
        :editor_button__selection_height__,
        :resource_selection__url__,
        :resource_selection__enabled__,
        :resource_selection__icon_url__,
        :resource_selection__selection_width__,
        :resource_selection__selection_height__,
        :config_type,
        :config_xml,
        :config_url,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "name is required" if name.nil?
      raise "privacy_level is required" if privacy_level.nil?
      raise "consumer_key is required" if consumer_key.nil?
      raise "shared_secret is required" if shared_secret.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :name => name,
        :privacy_level => privacy_level,
        :consumer_key => consumer_key,
        :shared_secret => shared_secret
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/external_tools",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Edit an external tool
    def edit_external_tool_courses(course_id,external_tool_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "external_tool_id is required" if external_tool_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :external_tool_id => external_tool_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/external_tools/{external_tool_id}",
        :course_id => course_id,
        :external_tool_id => external_tool_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Edit an external tool
    def edit_external_tool_accounts(account_id,external_tool_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "external_tool_id is required" if external_tool_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :external_tool_id => external_tool_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/external_tools/{external_tool_id}",
        :account_id => account_id,
        :external_tool_id => external_tool_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Delete an external tool
    def delete_external_tool_courses(course_id,external_tool_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "external_tool_id is required" if external_tool_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :external_tool_id => external_tool_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/external_tools/{external_tool_id}",
        :course_id => course_id,
        :external_tool_id => external_tool_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Delete an external tool
    def delete_external_tool_accounts(account_id,external_tool_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "external_tool_id is required" if external_tool_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :external_tool_id => external_tool_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/external_tools/{external_tool_id}",
        :account_id => account_id,
        :external_tool_id => external_tool_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # List favorite courses
    def list_favorite_courses(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/users/self/favorites/courses",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Course, path, query_params)
      
    end
    
    # Add course to favorites
    def add_course_to_favorites(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/users/self/favorites/courses/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Favorite.new(response)
      
    end
    
    # Remove course from favorites
    def remove_course_from_favorites(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/users/self/favorites/courses/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      Favorite.new(response)
      
    end
    
    # Reset course favorites
    def reset_course_favorites(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/users/self/favorites/courses",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # List features
    def list_features_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/features",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Feature, path, query_params)
      
    end
    
    # List features
    def list_features_accounts(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/features",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Feature, path, query_params)
      
    end
    
    # List features
    def list_features_users(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/features",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Feature, path, query_params)
      
    end
    
    # List enabled features
    def list_enabled_features_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/features/enabled",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List enabled features
    def list_enabled_features_accounts(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/features/enabled",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List enabled features
    def list_enabled_features_users(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/features/enabled",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get feature flag
    def get_feature_flag_courses(course_id,feature,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "feature is required" if feature.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :feature => feature
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/features/flags/{feature}",
        :course_id => course_id,
        :feature => feature)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      FeatureFlag.new(response)
      
    end
    
    # Get feature flag
    def get_feature_flag_accounts(account_id,feature,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "feature is required" if feature.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :feature => feature
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/features/flags/{feature}",
        :account_id => account_id,
        :feature => feature)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      FeatureFlag.new(response)
      
    end
    
    # Get feature flag
    def get_feature_flag_users(user_id,feature,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "feature is required" if feature.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :feature => feature
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/features/flags/{feature}",
        :user_id => user_id,
        :feature => feature)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      FeatureFlag.new(response)
      
    end
    
    # Set feature flag
    def set_feature_flag_courses(course_id,feature,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :state,
        :locking_account_id,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "feature is required" if feature.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :feature => feature
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/features/flags/{feature}",
        :course_id => course_id,
        :feature => feature)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      FeatureFlag.new(response)
      
    end
    
    # Set feature flag
    def set_feature_flag_accounts(account_id,feature,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :state,
        :locking_account_id,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "feature is required" if feature.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :feature => feature
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/features/flags/{feature}",
        :account_id => account_id,
        :feature => feature)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      FeatureFlag.new(response)
      
    end
    
    # Set feature flag
    def set_feature_flag_users(user_id,feature,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :state,
        :locking_account_id,
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "feature is required" if feature.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :feature => feature
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/features/flags/{feature}",
        :user_id => user_id,
        :feature => feature)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      FeatureFlag.new(response)
      
    end
    
    # Remove feature flag
    def remove_feature_flag_courses(course_id,feature,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "feature is required" if feature.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :feature => feature
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/features/flags/{feature}",
        :course_id => course_id,
        :feature => feature)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      FeatureFlag.new(response)
      
    end
    
    # Remove feature flag
    def remove_feature_flag_accounts(account_id,feature,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "feature is required" if feature.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :feature => feature
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/features/flags/{feature}",
        :account_id => account_id,
        :feature => feature)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      FeatureFlag.new(response)
      
    end
    
    # Remove feature flag
    def remove_feature_flag_users(user_id,feature,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "feature is required" if feature.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :feature => feature
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/features/flags/{feature}",
        :user_id => user_id,
        :feature => feature)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      FeatureFlag.new(response)
      
    end
    
    # Get quota information
    def get_quota_information_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/files/quota",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get quota information
    def get_quota_information_groups(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/files/quota",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get quota information
    def get_quota_information_users(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/files/quota",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List files
    def list_files_courses(course_id,opts={})
      query_param_keys = [
        :content_types,
        :search_term,
        :include,
        :sort,
        :order
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/files",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, File, path, query_params)
      
    end
    
    # List files
    def list_files_users(user_id,opts={})
      query_param_keys = [
        :content_types,
        :search_term,
        :include,
        :sort,
        :order
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/files",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, File, path, query_params)
      
    end
    
    # List files
    def list_files_groups(group_id,opts={})
      query_param_keys = [
        :content_types,
        :search_term,
        :include,
        :sort,
        :order
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/files",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, File, path, query_params)
      
    end
    
    # List files
    def list_files_folders(id,opts={})
      query_param_keys = [
        :content_types,
        :search_term,
        :include,
        :sort,
        :order
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/folders/{id}/files",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, File, path, query_params)
      
    end
    
    # Get quota information
    def get_quota_information(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/files/{id}/public_url",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get file
    def get_file(id,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/files/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      File.new(response)
      
    end
    
    # Update file
    def update_file(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :parent_folder_id,
        :on_duplicate,
        :lock_at,
        :unlock_at,
        :locked,
        :hidden,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/files/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      File.new(response)
      
    end
    
    # Delete file
    def delete_file(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/files/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # List folders
    def list_folders(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/folders/{id}/folders",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Folder, path, query_params)
      
    end
    
    # List all folders
    def list_all_folders_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/folders",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Folder, path, query_params)
      
    end
    
    # List all folders
    def list_all_folders_users(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/folders",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Folder, path, query_params)
      
    end
    
    # List all folders
    def list_all_folders_groups(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/folders",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Folder, path, query_params)
      
    end
    
    # Resolve path
    def resolve_path_courses_full_path(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/folders/by_path/*full_path",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Folder, path, query_params)
      
    end
    
    # Resolve path
    def resolve_path_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/folders/by_path",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Folder, path, query_params)
      
    end
    
    # Resolve path
    def resolve_path_users_full_path(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/folders/by_path/*full_path",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Folder, path, query_params)
      
    end
    
    # Resolve path
    def resolve_path_users(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/folders/by_path",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Folder, path, query_params)
      
    end
    
    # Resolve path
    def resolve_path_groups_full_path(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/folders/by_path/*full_path",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Folder, path, query_params)
      
    end
    
    # Resolve path
    def resolve_path_groups(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/folders/by_path",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Folder, path, query_params)
      
    end
    
    # Get folder
    def get_folder_courses(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/folders/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Folder.new(response)
      
    end
    
    # Get folder
    def get_folder_users(user_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/folders/{id}",
        :user_id => user_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Folder.new(response)
      
    end
    
    # Get folder
    def get_folder_groups(group_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/folders/{id}",
        :group_id => group_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Folder.new(response)
      
    end
    
    # Get folder
    def get_folder_folders(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/folders/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Folder.new(response)
      
    end
    
    # Update folder
    def update_folder(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :parent_folder_id,
        :lock_at,
        :unlock_at,
        :locked,
        :hidden,
        :position,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/folders/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      Folder.new(response)
      
    end
    
    # Create folder
    def create_folder_courses(course_id,name,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :parent_folder_id,
        :parent_folder_path,
        :lock_at,
        :unlock_at,
        :locked,
        :hidden,
        :position,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "name is required" if name.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :name => name
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/folders",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Folder.new(response)
      
    end
    
    # Create folder
    def create_folder_users(user_id,name,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :parent_folder_id,
        :parent_folder_path,
        :lock_at,
        :unlock_at,
        :locked,
        :hidden,
        :position,
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "name is required" if name.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :name => name
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/folders",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Folder.new(response)
      
    end
    
    # Create folder
    def create_folder_groups(group_id,name,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :parent_folder_id,
        :parent_folder_path,
        :lock_at,
        :unlock_at,
        :locked,
        :hidden,
        :position,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "name is required" if name.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :name => name
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/folders",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Folder.new(response)
      
    end
    
    # Create folder
    def create_folder_folders(folder_id,name,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :parent_folder_id,
        :parent_folder_path,
        :lock_at,
        :unlock_at,
        :locked,
        :hidden,
        :position,
        
      ]

      # verify existence of params
      raise "folder_id is required" if folder_id.nil?
      raise "name is required" if name.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :folder_id => folder_id,
        :name => name
      )

      # resource path
      path = path_replace("/v1/folders/{folder_id}/folders",
        :folder_id => folder_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Folder.new(response)
      
    end
    
    # Delete folder
    def delete_folder(id,opts={})
      query_param_keys = [
        :force
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/folders/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Upload a file
    def upload_file(folder_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "folder_id is required" if folder_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :folder_id => folder_id
      )

      # resource path
      path = path_replace("/v1/folders/{folder_id}/files",
        :folder_id => folder_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Copy a file
    def copy_file(dest_folder_id,source_file_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :source_file_id,
        :on_duplicate,
        
      ]

      # verify existence of params
      raise "dest_folder_id is required" if dest_folder_id.nil?
      raise "source_file_id is required" if source_file_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :dest_folder_id => dest_folder_id,
        :source_file_id => source_file_id
      )

      # resource path
      path = path_replace("/v1/folders/{dest_folder_id}/copy_file",
        :dest_folder_id => dest_folder_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      File.new(response)
      
    end
    
    # Copy a folder
    def copy_folder(dest_folder_id,source_folder_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :source_folder_id,
        
      ]

      # verify existence of params
      raise "dest_folder_id is required" if dest_folder_id.nil?
      raise "source_folder_id is required" if source_folder_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :dest_folder_id => dest_folder_id,
        :source_folder_id => source_folder_id
      )

      # resource path
      path = path_replace("/v1/folders/{dest_folder_id}/copy_folder",
        :dest_folder_id => dest_folder_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Folder.new(response)
      
    end
    
    # Set usage rights
    def set_usage_rights_courses(course_id,file_ids,usage_rights__use_justification__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :file_ids,
        :folder_ids,
        :publish,
        :usage_rights__use_justification__,
        :usage_rights__legal_copyright__,
        :usage_rights__license__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "file_ids is required" if file_ids.nil?
      raise "usage_rights__use_justification__ is required" if usage_rights__use_justification__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :file_ids => file_ids,
        :usage_rights__use_justification__ => usage_rights__use_justification__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/usage_rights",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      UsageRights.new(response)
      
    end
    
    # Set usage rights
    def set_usage_rights_groups(group_id,file_ids,usage_rights__use_justification__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :file_ids,
        :folder_ids,
        :publish,
        :usage_rights__use_justification__,
        :usage_rights__legal_copyright__,
        :usage_rights__license__,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "file_ids is required" if file_ids.nil?
      raise "usage_rights__use_justification__ is required" if usage_rights__use_justification__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :file_ids => file_ids,
        :usage_rights__use_justification__ => usage_rights__use_justification__
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/usage_rights",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      UsageRights.new(response)
      
    end
    
    # Set usage rights
    def set_usage_rights_users(user_id,file_ids,usage_rights__use_justification__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :file_ids,
        :folder_ids,
        :publish,
        :usage_rights__use_justification__,
        :usage_rights__legal_copyright__,
        :usage_rights__license__,
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "file_ids is required" if file_ids.nil?
      raise "usage_rights__use_justification__ is required" if usage_rights__use_justification__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :file_ids => file_ids,
        :usage_rights__use_justification__ => usage_rights__use_justification__
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/usage_rights",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      UsageRights.new(response)
      
    end
    
    # Remove usage rights
    def remove_usage_rights_courses(course_id,file_ids,opts={})
      query_param_keys = [
        :file_ids,
        :folder_ids
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "file_ids is required" if file_ids.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :file_ids => file_ids
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/usage_rights",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Remove usage rights
    def remove_usage_rights_groups(group_id,file_ids,opts={})
      query_param_keys = [
        :file_ids,
        :folder_ids
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "file_ids is required" if file_ids.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :file_ids => file_ids
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/usage_rights",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Remove usage rights
    def remove_usage_rights_users(user_id,file_ids,opts={})
      query_param_keys = [
        :file_ids,
        :folder_ids
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "file_ids is required" if file_ids.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :file_ids => file_ids
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/usage_rights",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # List licenses
    def list_licenses_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/content_licenses",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, License, path, query_params)
      
    end
    
    # List licenses
    def list_licenses_groups(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/content_licenses",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, License, path, query_params)
      
    end
    
    # List licenses
    def list_licenses_users(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/content_licenses",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, License, path, query_params)
      
    end
    
    # Query by assignment.
    def query_by_assignment(assignment_id,opts={})
      query_param_keys = [
        :start_time,
        :end_time
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "assignment_id is required" if assignment_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :assignment_id => assignment_id
      )

      # resource path
      path = path_replace("/v1/audit/grade_change/assignments/{assignment_id}",
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, GradeChangeEvent, path, query_params)
      
    end
    
    # Query by course.
    def query_by_course(course_id,opts={})
      query_param_keys = [
        :start_time,
        :end_time
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/audit/grade_change/courses/{course_id}",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, GradeChangeEvent, path, query_params)
      
    end
    
    # Query by student.
    def query_by_student(student_id,opts={})
      query_param_keys = [
        :start_time,
        :end_time
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "student_id is required" if student_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :student_id => student_id
      )

      # resource path
      path = path_replace("/v1/audit/grade_change/students/{student_id}",
        :student_id => student_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, GradeChangeEvent, path, query_params)
      
    end
    
    # Query by grader.
    def query_by_grader(grader_id,opts={})
      query_param_keys = [
        :start_time,
        :end_time
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "grader_id is required" if grader_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :grader_id => grader_id
      )

      # resource path
      path = path_replace("/v1/audit/grade_change/graders/{grader_id}",
        :grader_id => grader_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, GradeChangeEvent, path, query_params)
      
    end
    
    # Days in gradebook history for this course
    def days_in_gradebook_history_for_this_course(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/gradebook_history/days",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Day, path, query_params)
      
    end
    
    # Details for a given date in gradebook history for this course
    def details_for_given_date_in_gradebook_history_for_this_course(course_id,date,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "date is required" if date.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :date => date
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/gradebook_history/{date}",
        :course_id => course_id,
        :date => date)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Grader, path, query_params)
      
    end
    
    # Lists submissions
    def lists_submissions(course_id,date,grader_id,assignment_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "date is required" if date.nil?
      raise "grader_id is required" if grader_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :date => date,
        :grader_id => grader_id,
        :assignment_id => assignment_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/gradebook_history/{date}/graders/{grader_id}/assignments/{assignment_id}/submissions",
        :course_id => course_id,
        :date => date,
        :grader_id => grader_id,
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, SubmissionHistory, path, query_params)
      
    end
    
    # List uncollated submission versions
    def list_uncollated_submission_versions(course_id,opts={})
      query_param_keys = [
        :assignment_id,
        :user_id,
        :ascending
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/gradebook_history/feed",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, SubmissionVersion, path, query_params)
      
    end
    
    # List grading periods
    def list_grading_periods_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/grading_periods",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List grading periods
    def list_grading_periods_accounts(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/grading_periods",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get a single grading period
    def get_single_grading_period_courses(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/grading_periods/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get a single grading period
    def get_single_grading_period_accounts(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/grading_periods/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Create a single grading period
    def create_single_grading_period_courses(course_id,grading_periods__start_date__,grading_periods__end_date__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :grading_periods__start_date__,
        :grading_periods__end_date__,
        :grading_periods__weight__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "grading_periods__start_date__ is required" if grading_periods__start_date__.nil?
      raise "grading_periods__end_date__ is required" if grading_periods__end_date__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :grading_periods__start_date__ => grading_periods__start_date__,
        :grading_periods__end_date__ => grading_periods__end_date__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/grading_periods",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Create a single grading period
    def create_single_grading_period_accounts(account_id,grading_periods__start_date__,grading_periods__end_date__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :grading_periods__start_date__,
        :grading_periods__end_date__,
        :grading_periods__weight__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "grading_periods__start_date__ is required" if grading_periods__start_date__.nil?
      raise "grading_periods__end_date__ is required" if grading_periods__end_date__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :grading_periods__start_date__ => grading_periods__start_date__,
        :grading_periods__end_date__ => grading_periods__end_date__
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/grading_periods",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Update a single grading period
    def update_single_grading_period_courses(course_id,id,grading_periods__start_date__,grading_periods__end_date__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :grading_periods__start_date__,
        :grading_periods__end_date__,
        :grading_periods__weight__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      raise "grading_periods__start_date__ is required" if grading_periods__start_date__.nil?
      raise "grading_periods__end_date__ is required" if grading_periods__end_date__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id,
        :grading_periods__start_date__ => grading_periods__start_date__,
        :grading_periods__end_date__ => grading_periods__end_date__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/grading_periods/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Update a single grading period
    def update_single_grading_period_accounts(account_id,id,grading_periods__start_date__,grading_periods__end_date__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :grading_periods__start_date__,
        :grading_periods__end_date__,
        :grading_periods__weight__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      raise "grading_periods__start_date__ is required" if grading_periods__start_date__.nil?
      raise "grading_periods__end_date__ is required" if grading_periods__end_date__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id,
        :grading_periods__start_date__ => grading_periods__start_date__,
        :grading_periods__end_date__ => grading_periods__end_date__
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/grading_periods/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Delete a grading period
    def delete_grading_period_courses(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/grading_periods/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Delete a grading period
    def delete_grading_period_accounts(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/grading_periods/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Create a new grading standard
    def create_new_grading_standard_accounts(account_id,title,grading_scheme_entry__name__,grading_scheme_entry__value__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :grading_scheme_entry__name__,
        :grading_scheme_entry__value__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "title is required" if title.nil?
      raise "grading_scheme_entry__name__ is required" if grading_scheme_entry__name__.nil?
      raise "grading_scheme_entry__value__ is required" if grading_scheme_entry__value__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :title => title,
        :grading_scheme_entry__name__ => grading_scheme_entry__name__,
        :grading_scheme_entry__value__ => grading_scheme_entry__value__
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/grading_standards",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      GradingStandard.new(response)
      
    end
    
    # Create a new grading standard
    def create_new_grading_standard_courses(course_id,title,grading_scheme_entry__name__,grading_scheme_entry__value__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :grading_scheme_entry__name__,
        :grading_scheme_entry__value__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "title is required" if title.nil?
      raise "grading_scheme_entry__name__ is required" if grading_scheme_entry__name__.nil?
      raise "grading_scheme_entry__value__ is required" if grading_scheme_entry__value__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :title => title,
        :grading_scheme_entry__name__ => grading_scheme_entry__name__,
        :grading_scheme_entry__value__ => grading_scheme_entry__value__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/grading_standards",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      GradingStandard.new(response)
      
    end
    
    # List group categories for a context
    def list_group_categories_for_context_accounts(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/group_categories",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, GroupCategory, path, query_params)
      
    end
    
    # List group categories for a context
    def list_group_categories_for_context_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/group_categories",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, GroupCategory, path, query_params)
      
    end
    
    # Get a single group category
    def get_single_group_category(group_category_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_category_id is required" if group_category_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_category_id => group_category_id
      )

      # resource path
      path = path_replace("/v1/group_categories/{group_category_id}",
        :group_category_id => group_category_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      GroupCategory.new(response)
      
    end
    
    # Create a Group Category
    def create_group_category_accounts(account_id,name,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :self_signup,
        :auto_leader,
        :group_limit,
        :create_group_count,
        :split_group_count,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "name is required" if name.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :name => name
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/group_categories",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      GroupCategory.new(response)
      
    end
    
    # Create a Group Category
    def create_group_category_courses(course_id,name,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :self_signup,
        :auto_leader,
        :group_limit,
        :create_group_count,
        :split_group_count,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "name is required" if name.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :name => name
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/group_categories",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      GroupCategory.new(response)
      
    end
    
    # Update a Group Category
    def update_group_category(group_category_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :self_signup,
        :auto_leader,
        :group_limit,
        :create_group_count,
        :split_group_count,
        
      ]

      # verify existence of params
      raise "group_category_id is required" if group_category_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_category_id => group_category_id
      )

      # resource path
      path = path_replace("/v1/group_categories/{group_category_id}",
        :group_category_id => group_category_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      GroupCategory.new(response)
      
    end
    
    # Delete a Group Category
    def delete_group_category(group_category_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_category_id is required" if group_category_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_category_id => group_category_id
      )

      # resource path
      path = path_replace("/v1/group_categories/{group_category_id}",
        :group_category_id => group_category_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # List groups in group category
    def list_groups_in_group_category(group_category_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_category_id is required" if group_category_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_category_id => group_category_id
      )

      # resource path
      path = path_replace("/v1/group_categories/{group_category_id}/groups",
        :group_category_id => group_category_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Group, path, query_params)
      
    end
    
    # List users in group category
    def list_users_in_group_category(group_category_id,opts={})
      query_param_keys = [
        :search_term,
        :unassigned
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_category_id is required" if group_category_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_category_id => group_category_id
      )

      # resource path
      path = path_replace("/v1/group_categories/{group_category_id}/users",
        :group_category_id => group_category_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, User, path, query_params)
      
    end
    
    # Assign unassigned members
    def assign_unassigned_members(group_category_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :sync,
        
      ]

      # verify existence of params
      raise "group_category_id is required" if group_category_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_category_id => group_category_id
      )

      # resource path
      path = path_replace("/v1/group_categories/{group_category_id}/assign_unassigned_members",
        :group_category_id => group_category_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      GroupMembership | Progress.new(response)
      
    end
    
    # List your groups
    def list_your_groups(opts={})
      query_param_keys = [
        :context_type
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/users/self/groups",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Group, path, query_params)
      
    end
    
    # List the groups available in a context.
    def list_groups_available_in_context_accounts(account_id,opts={})
      query_param_keys = [
        :only_own_groups
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/groups",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Group, path, query_params)
      
    end
    
    # List the groups available in a context.
    def list_groups_available_in_context_courses(course_id,opts={})
      query_param_keys = [
        :only_own_groups
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/groups",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Group, path, query_params)
      
    end
    
    # Get a single group
    def get_single_group(group_id,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Group.new(response)
      
    end
    
    # Create a group
    def create_group_groups(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :description,
        :is_public,
        :join_level,
        :storage_quota_mb,
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/groups",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Group.new(response)
      
    end
    
    # Create a group
    def create_group_group_categories(group_category_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :description,
        :is_public,
        :join_level,
        :storage_quota_mb,
        
      ]

      # verify existence of params
      raise "group_category_id is required" if group_category_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_category_id => group_category_id
      )

      # resource path
      path = path_replace("/v1/group_categories/{group_category_id}/groups",
        :group_category_id => group_category_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Group.new(response)
      
    end
    
    # Edit a group
    def edit_group(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :description,
        :is_public,
        :join_level,
        :avatar_id,
        :storage_quota_mb,
        :members,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      Group.new(response)
      
    end
    
    # Delete a group
    def delete_group(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      Group.new(response)
      
    end
    
    # Invite others to a group
    def invite_others_to_group(group_id,invitees,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :invitees,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "invitees is required" if invitees.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :invitees => invitees
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/invite",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # List group's users
    def list_group_s_users(group_id,opts={})
      query_param_keys = [
        :search_term,
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/users",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, User, path, query_params)
      
    end
    
    # Upload a file
    def upload_file(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/files",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Preview processed html
    def preview_processed_html(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :html,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/preview_html",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Group activity stream
    def group_activity_stream(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/activity_stream",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Group activity stream summary
    def group_activity_stream_summary(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/activity_stream/summary",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List group memberships
    def list_group_memberships(group_id,opts={})
      query_param_keys = [
        :filter_states
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/memberships",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, GroupMembership, path, query_params)
      
    end
    
    # Create a membership
    def create_membership(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :user_id,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/memberships",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      GroupMembership.new(response)
      
    end
    
    # Update a membership
    def update_membership_memberships(group_id,membership_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :workflow_state,
        :moderator,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "membership_id is required" if membership_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :membership_id => membership_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/memberships/{membership_id}",
        :group_id => group_id,
        :membership_id => membership_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      GroupMembership.new(response)
      
    end
    
    # Update a membership
    def update_membership_users(group_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :workflow_state,
        :moderator,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/users/{user_id}",
        :group_id => group_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      GroupMembership.new(response)
      
    end
    
    # Leave a group
    def leave_group_memberships(group_id,membership_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "membership_id is required" if membership_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :membership_id => membership_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/memberships/{membership_id}",
        :group_id => group_id,
        :membership_id => membership_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Leave a group
    def leave_group_users(group_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/users/{user_id}",
        :group_id => group_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Create live assessment results
    def create_live_assessment_results(course_id,assessment_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assessment_id is required" if assessment_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assessment_id => assessment_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/live_assessments/{assessment_id}/results",
        :course_id => course_id,
        :assessment_id => assessment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # List live assessment results
    def list_live_assessment_results(course_id,assessment_id,opts={})
      query_param_keys = [
        :user_id
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assessment_id is required" if assessment_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assessment_id => assessment_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/live_assessments/{assessment_id}/results",
        :course_id => course_id,
        :assessment_id => assessment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Create or find a live assessment
    def create_or_find_live_assessment(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/live_assessments",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # List live assessments
    def list_live_assessments(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/live_assessments",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List user logins
    def list_user_logins_accounts(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/logins",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List user logins
    def list_user_logins_users(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/logins",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Create a user login
    def create_user_login(account_id,user__id__,login__unique_id__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :user__id__,
        :login__unique_id__,
        :login__password__,
        :login__sis_user_id__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "user__id__ is required" if user__id__.nil?
      raise "login__unique_id__ is required" if login__unique_id__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :user__id__ => user__id__,
        :login__unique_id__ => login__unique_id__
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/logins",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Edit a user login
    def edit_user_login(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :login__unique_id__,
        :login__password__,
        :login__sis_user_id__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/logins/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Delete a user login
    def delete_user_login(user_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/logins/{id}",
        :user_id => user_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # List modules
    def list_modules(course_id,opts={})
      query_param_keys = [
        :include,
        :search_term,
        :student_id
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Module, path, query_params)
      
    end
    
    # Show module
    def show_module(course_id,id,opts={})
      query_param_keys = [
        :include,
        :student_id
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Module.new(response)
      
    end
    
    # Create a module
    def create_module(course_id,module__name__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :module__name__,
        :module__unlock_at__,
        :module__position__,
        :module__require_sequential_progress__,
        :module__prerequisite_module_ids__,
        :module__publish_final_grade__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "module__name__ is required" if module__name__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :module__name__ => module__name__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Module.new(response)
      
    end
    
    # Update a module
    def update_module(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :module__name__,
        :module__unlock_at__,
        :module__position__,
        :module__require_sequential_progress__,
        :module__prerequisite_module_ids__,
        :module__publish_final_grade__,
        :module__published__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      Module.new(response)
      
    end
    
    # Delete module
    def delete_module(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      Module.new(response)
      
    end
    
    # Re-lock module progressions
    def re_lock_module_progressions(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules/{id}/relock",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      Module.new(response)
      
    end
    
    # List module items
    def list_module_items(course_id,module_id,opts={})
      query_param_keys = [
        :include,
        :search_term,
        :student_id
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "module_id is required" if module_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :module_id => module_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules/{module_id}/items",
        :course_id => course_id,
        :module_id => module_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, ModuleItem, path, query_params)
      
    end
    
    # Show module item
    def show_module_item(course_id,module_id,id,opts={})
      query_param_keys = [
        :include,
        :student_id
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "module_id is required" if module_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :module_id => module_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules/{module_id}/items/{id}",
        :course_id => course_id,
        :module_id => module_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      ModuleItem.new(response)
      
    end
    
    # Create a module item
    def create_module_item(course_id,module_id,module_item__type__,module_item__content_id__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :module_item__title__,
        :module_item__type__,
        :module_item__content_id__,
        :module_item__position__,
        :module_item__indent__,
        :module_item__page_url__,
        :module_item__external_url__,
        :module_item__new_tab__,
        :module_item__completion_requirement____type__,
        :module_item__completion_requirement____min_score__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "module_id is required" if module_id.nil?
      raise "module_item__type__ is required" if module_item__type__.nil?
      raise "module_item__content_id__ is required" if module_item__content_id__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :module_id => module_id,
        :module_item__type__ => module_item__type__,
        :module_item__content_id__ => module_item__content_id__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules/{module_id}/items",
        :course_id => course_id,
        :module_id => module_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      ModuleItem.new(response)
      
    end
    
    # Update a module item
    def update_module_item(course_id,module_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :module_item__title__,
        :module_item__position__,
        :module_item__indent__,
        :module_item__external_url__,
        :module_item__new_tab__,
        :module_item__completion_requirement____type__,
        :module_item__completion_requirement____min_score__,
        :module_item__published__,
        :module_item__module_id__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "module_id is required" if module_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :module_id => module_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules/{module_id}/items/{id}",
        :course_id => course_id,
        :module_id => module_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      ModuleItem.new(response)
      
    end
    
    # Delete module item
    def delete_module_item(course_id,module_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "module_id is required" if module_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :module_id => module_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules/{module_id}/items/{id}",
        :course_id => course_id,
        :module_id => module_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      ModuleItem.new(response)
      
    end
    
    # Get module item sequence
    def get_module_item_sequence(course_id,opts={})
      query_param_keys = [
        :asset_type,
        :asset_id
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/module_item_sequence",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      ModuleItemSequence.new(response)
      
    end
    
    # Mark module item read
    def mark_module_item_read(course_id,module_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "module_id is required" if module_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :module_id => module_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/modules/{module_id}/items/{id}/mark_read",
        :course_id => course_id,
        :module_id => module_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # List preferences
    def list_preferences_communication_channel_id(user_id,communication_channel_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "communication_channel_id is required" if communication_channel_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :communication_channel_id => communication_channel_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/communication_channels/{communication_channel_id}/notification_preferences",
        :user_id => user_id,
        :communication_channel_id => communication_channel_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, NotificationPreference, path, query_params)
      
    end
    
    # List preferences
    def list_preferences_type(user_id,type,address,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "type is required" if type.nil?
      raise "address is required" if address.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :type => type,
        :address => address
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/communication_channels/{type}/{address}/notification_preferences",
        :user_id => user_id,
        :type => type,
        :address => address)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, NotificationPreference, path, query_params)
      
    end
    
    # Get a preference
    def get_preference_communication_channel_id(user_id,communication_channel_id,notification,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "communication_channel_id is required" if communication_channel_id.nil?
      raise "notification is required" if notification.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :communication_channel_id => communication_channel_id,
        :notification => notification
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/communication_channels/{communication_channel_id}/notification_preferences/{notification}",
        :user_id => user_id,
        :communication_channel_id => communication_channel_id,
        :notification => notification)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      NotificationPreference.new(response)
      
    end
    
    # Get a preference
    def get_preference_type(user_id,type,address,notification,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "type is required" if type.nil?
      raise "address is required" if address.nil?
      raise "notification is required" if notification.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :type => type,
        :address => address,
        :notification => notification
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/communication_channels/{type}/{address}/notification_preferences/{notification}",
        :user_id => user_id,
        :type => type,
        :address => address,
        :notification => notification)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      NotificationPreference.new(response)
      
    end
    
    # Update a preference
    def update_preference_communication_channel_id(communication_channel_id,notification,notification_preferences__frequency__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :notification_preferences__frequency__,
        
      ]

      # verify existence of params
      raise "communication_channel_id is required" if communication_channel_id.nil?
      raise "notification is required" if notification.nil?
      raise "notification_preferences__frequency__ is required" if notification_preferences__frequency__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :communication_channel_id => communication_channel_id,
        :notification => notification,
        :notification_preferences__frequency__ => notification_preferences__frequency__
      )

      # resource path
      path = path_replace("/v1/users/self/communication_channels/{communication_channel_id}/notification_preferences/{notification}",
        :communication_channel_id => communication_channel_id,
        :notification => notification)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Update a preference
    def update_preference_type(type,address,notification,notification_preferences__frequency__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :notification_preferences__frequency__,
        
      ]

      # verify existence of params
      raise "type is required" if type.nil?
      raise "address is required" if address.nil?
      raise "notification is required" if notification.nil?
      raise "notification_preferences__frequency__ is required" if notification_preferences__frequency__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :type => type,
        :address => address,
        :notification => notification,
        :notification_preferences__frequency__ => notification_preferences__frequency__
      )

      # resource path
      path = path_replace("/v1/users/self/communication_channels/{type}/{address}/notification_preferences/{notification}",
        :type => type,
        :address => address,
        :notification => notification)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Update multiple preferences
    def update_multiple_preferences_communication_channel_id(communication_channel_id,notification_preferences____x_____frequency__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :notification_preferences____x_____frequency__,
        
      ]

      # verify existence of params
      raise "communication_channel_id is required" if communication_channel_id.nil?
      raise "notification_preferences____x_____frequency__ is required" if notification_preferences____x_____frequency__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :communication_channel_id => communication_channel_id,
        :notification_preferences____x_____frequency__ => notification_preferences____x_____frequency__
      )

      # resource path
      path = path_replace("/v1/users/self/communication_channels/{communication_channel_id}/notification_preferences",
        :communication_channel_id => communication_channel_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Update multiple preferences
    def update_multiple_preferences_type(type,address,notification_preferences____x_____frequency__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :notification_preferences____x_____frequency__,
        
      ]

      # verify existence of params
      raise "type is required" if type.nil?
      raise "address is required" if address.nil?
      raise "notification_preferences____x_____frequency__ is required" if notification_preferences____x_____frequency__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :type => type,
        :address => address,
        :notification_preferences____x_____frequency__ => notification_preferences____x_____frequency__
      )

      # resource path
      path = path_replace("/v1/users/self/communication_channels/{type}/{address}/notification_preferences",
        :type => type,
        :address => address)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Redirect to root outcome group for context
    def redirect_to_root_outcome_group_for_context_global(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/global/root_outcome_group",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Redirect to root outcome group for context
    def redirect_to_root_outcome_group_for_context_accounts(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/root_outcome_group",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Redirect to root outcome group for context
    def redirect_to_root_outcome_group_for_context_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/root_outcome_group",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get all outcome groups for context
    def get_all_outcome_groups_for_context_accounts(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_groups",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, OutcomeGroup, path, query_params)
      
    end
    
    # Get all outcome groups for context
    def get_all_outcome_groups_for_context_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_groups",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, OutcomeGroup, path, query_params)
      
    end
    
    # Get all outcome links for context
    def get_all_outcome_links_for_context_accounts(account_id,opts={})
      query_param_keys = [
        :outcome_style,
        :outcome_group_style
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_group_links",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, OutcomeLink, path, query_params)
      
    end
    
    # Get all outcome links for context
    def get_all_outcome_links_for_context_courses(course_id,opts={})
      query_param_keys = [
        :outcome_style,
        :outcome_group_style
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_group_links",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, OutcomeLink, path, query_params)
      
    end
    
    # Show an outcome group
    def show_outcome_group_global(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/global/outcome_groups/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      OutcomeGroup.new(response)
      
    end
    
    # Show an outcome group
    def show_outcome_group_accounts(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_groups/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      OutcomeGroup.new(response)
      
    end
    
    # Show an outcome group
    def show_outcome_group_courses(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_groups/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      OutcomeGroup.new(response)
      
    end
    
    # Update an outcome group
    def update_outcome_group_global(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :description,
        :vendor_guid,
        :parent_outcome_group_id,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/global/outcome_groups/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      OutcomeGroup.new(response)
      
    end
    
    # Update an outcome group
    def update_outcome_group_accounts(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :description,
        :vendor_guid,
        :parent_outcome_group_id,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_groups/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      OutcomeGroup.new(response)
      
    end
    
    # Update an outcome group
    def update_outcome_group_courses(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :description,
        :vendor_guid,
        :parent_outcome_group_id,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_groups/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      OutcomeGroup.new(response)
      
    end
    
    # Delete an outcome group
    def delete_outcome_group_global(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/global/outcome_groups/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      OutcomeGroup.new(response)
      
    end
    
    # Delete an outcome group
    def delete_outcome_group_accounts(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_groups/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      OutcomeGroup.new(response)
      
    end
    
    # Delete an outcome group
    def delete_outcome_group_courses(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_groups/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      OutcomeGroup.new(response)
      
    end
    
    # List linked outcomes
    def list_linked_outcomes_global(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/global/outcome_groups/{id}/outcomes",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, OutcomeLink, path, query_params)
      
    end
    
    # List linked outcomes
    def list_linked_outcomes_accounts(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_groups/{id}/outcomes",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, OutcomeLink, path, query_params)
      
    end
    
    # List linked outcomes
    def list_linked_outcomes_courses(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_groups/{id}/outcomes",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, OutcomeLink, path, query_params)
      
    end
    
    # Create/link an outcome
    def create_link_outcome_global(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :outcome_id,
        :title,
        :display_name,
        :description,
        :vendor_guid,
        :mastery_points,
        :ratings__description__,
        :ratings__points__,
        :calculation_method,
        :calculation_int,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/global/outcome_groups/{id}/outcomes",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      OutcomeLink.new(response)
      
    end
    
    # Create/link an outcome
    def create_link_outcome_global_outcome_id(id,outcome_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :display_name,
        :description,
        :vendor_guid,
        :mastery_points,
        :ratings__description__,
        :ratings__points__,
        :calculation_method,
        :calculation_int,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "outcome_id is required" if outcome_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :outcome_id => outcome_id
      )

      # resource path
      path = path_replace("/v1/global/outcome_groups/{id}/outcomes/{outcome_id}",
        :id => id,
        :outcome_id => outcome_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      OutcomeLink.new(response)
      
    end
    
    # Create/link an outcome
    def create_link_outcome_accounts(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :outcome_id,
        :title,
        :display_name,
        :description,
        :vendor_guid,
        :mastery_points,
        :ratings__description__,
        :ratings__points__,
        :calculation_method,
        :calculation_int,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_groups/{id}/outcomes",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      OutcomeLink.new(response)
      
    end
    
    # Create/link an outcome
    def create_link_outcome_accounts_outcome_id(account_id,id,outcome_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :display_name,
        :description,
        :vendor_guid,
        :mastery_points,
        :ratings__description__,
        :ratings__points__,
        :calculation_method,
        :calculation_int,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      raise "outcome_id is required" if outcome_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id,
        :outcome_id => outcome_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_groups/{id}/outcomes/{outcome_id}",
        :account_id => account_id,
        :id => id,
        :outcome_id => outcome_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      OutcomeLink.new(response)
      
    end
    
    # Create/link an outcome
    def create_link_outcome_courses(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :outcome_id,
        :title,
        :display_name,
        :description,
        :vendor_guid,
        :mastery_points,
        :ratings__description__,
        :ratings__points__,
        :calculation_method,
        :calculation_int,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_groups/{id}/outcomes",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      OutcomeLink.new(response)
      
    end
    
    # Create/link an outcome
    def create_link_outcome_courses_outcome_id(course_id,id,outcome_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :display_name,
        :description,
        :vendor_guid,
        :mastery_points,
        :ratings__description__,
        :ratings__points__,
        :calculation_method,
        :calculation_int,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      raise "outcome_id is required" if outcome_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id,
        :outcome_id => outcome_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_groups/{id}/outcomes/{outcome_id}",
        :course_id => course_id,
        :id => id,
        :outcome_id => outcome_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      OutcomeLink.new(response)
      
    end
    
    # Unlink an outcome
    def unlink_outcome_global(id,outcome_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "outcome_id is required" if outcome_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :outcome_id => outcome_id
      )

      # resource path
      path = path_replace("/v1/global/outcome_groups/{id}/outcomes/{outcome_id}",
        :id => id,
        :outcome_id => outcome_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      OutcomeLink.new(response)
      
    end
    
    # Unlink an outcome
    def unlink_outcome_accounts(account_id,id,outcome_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      raise "outcome_id is required" if outcome_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id,
        :outcome_id => outcome_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_groups/{id}/outcomes/{outcome_id}",
        :account_id => account_id,
        :id => id,
        :outcome_id => outcome_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      OutcomeLink.new(response)
      
    end
    
    # Unlink an outcome
    def unlink_outcome_courses(course_id,id,outcome_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      raise "outcome_id is required" if outcome_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id,
        :outcome_id => outcome_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_groups/{id}/outcomes/{outcome_id}",
        :course_id => course_id,
        :id => id,
        :outcome_id => outcome_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      OutcomeLink.new(response)
      
    end
    
    # List subgroups
    def list_subgroups_global(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/global/outcome_groups/{id}/subgroups",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, OutcomeGroup, path, query_params)
      
    end
    
    # List subgroups
    def list_subgroups_accounts(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_groups/{id}/subgroups",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, OutcomeGroup, path, query_params)
      
    end
    
    # List subgroups
    def list_subgroups_courses(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_groups/{id}/subgroups",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, OutcomeGroup, path, query_params)
      
    end
    
    # Create a subgroup
    def create_subgroup_global(id,title,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :description,
        :vendor_guid,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "title is required" if title.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :title => title
      )

      # resource path
      path = path_replace("/v1/global/outcome_groups/{id}/subgroups",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      OutcomeGroup.new(response)
      
    end
    
    # Create a subgroup
    def create_subgroup_accounts(account_id,id,title,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :description,
        :vendor_guid,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      raise "title is required" if title.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id,
        :title => title
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_groups/{id}/subgroups",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      OutcomeGroup.new(response)
      
    end
    
    # Create a subgroup
    def create_subgroup_courses(course_id,id,title,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :description,
        :vendor_guid,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      raise "title is required" if title.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id,
        :title => title
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_groups/{id}/subgroups",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      OutcomeGroup.new(response)
      
    end
    
    # Import an outcome group
    def import_outcome_group_global(id,source_outcome_group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :source_outcome_group_id,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "source_outcome_group_id is required" if source_outcome_group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :source_outcome_group_id => source_outcome_group_id
      )

      # resource path
      path = path_replace("/v1/global/outcome_groups/{id}/import",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      OutcomeGroup.new(response)
      
    end
    
    # Import an outcome group
    def import_outcome_group_accounts(account_id,id,source_outcome_group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :source_outcome_group_id,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      raise "source_outcome_group_id is required" if source_outcome_group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id,
        :source_outcome_group_id => source_outcome_group_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/outcome_groups/{id}/import",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      OutcomeGroup.new(response)
      
    end
    
    # Import an outcome group
    def import_outcome_group_courses(course_id,id,source_outcome_group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :source_outcome_group_id,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      raise "source_outcome_group_id is required" if source_outcome_group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id,
        :source_outcome_group_id => source_outcome_group_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_groups/{id}/import",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      OutcomeGroup.new(response)
      
    end
    
    # Get outcome results
    def get_outcome_results(course_id,opts={})
      query_param_keys = [
        :user_ids,
        :outcome_ids,
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_results",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get outcome result rollups
    def get_outcome_result_rollups(course_id,opts={})
      query_param_keys = [
        :aggregate,
        :user_ids,
        :outcome_ids,
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/outcome_rollups",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Show an outcome
    def show_outcome(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/outcomes/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Outcome.new(response)
      
    end
    
    # Update an outcome
    def update_outcome(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :title,
        :display_name,
        :description,
        :vendor_guid,
        :mastery_points,
        :ratings__description__,
        :ratings__points__,
        :calculation_method,
        :calculation_int,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/outcomes/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      Outcome.new(response)
      
    end
    
    # Show front page
    def show_front_page_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/front_page",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Page.new(response)
      
    end
    
    # Show front page
    def show_front_page_groups(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/front_page",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Page.new(response)
      
    end
    
    # Update/create front page
    def update_create_front_page_courses(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :wiki_page__title__,
        :wiki_page__body__,
        :wiki_page__editing_roles__,
        :wiki_page__notify_of_update__,
        :wiki_page__published__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/front_page",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      Page.new(response)
      
    end
    
    # Update/create front page
    def update_create_front_page_groups(group_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :wiki_page__title__,
        :wiki_page__body__,
        :wiki_page__editing_roles__,
        :wiki_page__notify_of_update__,
        :wiki_page__published__,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/front_page",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      Page.new(response)
      
    end
    
    # List pages
    def list_pages_courses(course_id,opts={})
      query_param_keys = [
        :sort,
        :order,
        :search_term,
        :published
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/pages",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Page, path, query_params)
      
    end
    
    # List pages
    def list_pages_groups(group_id,opts={})
      query_param_keys = [
        :sort,
        :order,
        :search_term,
        :published
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/pages",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Page, path, query_params)
      
    end
    
    # Create page
    def create_page_courses(course_id,wiki_page__title__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :wiki_page__title__,
        :wiki_page__body__,
        :wiki_page__editing_roles__,
        :wiki_page__notify_of_update__,
        :wiki_page__published__,
        :wiki_page__front_page__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "wiki_page__title__ is required" if wiki_page__title__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :wiki_page__title__ => wiki_page__title__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/pages",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Page.new(response)
      
    end
    
    # Create page
    def create_page_groups(group_id,wiki_page__title__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :wiki_page__title__,
        :wiki_page__body__,
        :wiki_page__editing_roles__,
        :wiki_page__notify_of_update__,
        :wiki_page__published__,
        :wiki_page__front_page__,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "wiki_page__title__ is required" if wiki_page__title__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :wiki_page__title__ => wiki_page__title__
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/pages",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Page.new(response)
      
    end
    
    # Show page
    def show_page_courses(course_id,url,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "url is required" if url.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :url => url
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/pages/{url}",
        :course_id => course_id,
        :url => url)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Page.new(response)
      
    end
    
    # Show page
    def show_page_groups(group_id,url,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "url is required" if url.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :url => url
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/pages/{url}",
        :group_id => group_id,
        :url => url)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Page.new(response)
      
    end
    
    # Update/create page
    def update_create_page_courses(course_id,url,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :wiki_page__title__,
        :wiki_page__body__,
        :wiki_page__editing_roles__,
        :wiki_page__notify_of_update__,
        :wiki_page__published__,
        :wiki_page__front_page__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "url is required" if url.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :url => url
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/pages/{url}",
        :course_id => course_id,
        :url => url)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      Page.new(response)
      
    end
    
    # Update/create page
    def update_create_page_groups(group_id,url,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :wiki_page__title__,
        :wiki_page__body__,
        :wiki_page__editing_roles__,
        :wiki_page__notify_of_update__,
        :wiki_page__published__,
        :wiki_page__front_page__,
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "url is required" if url.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :url => url
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/pages/{url}",
        :group_id => group_id,
        :url => url)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      Page.new(response)
      
    end
    
    # Delete page
    def delete_page_courses(course_id,url,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "url is required" if url.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :url => url
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/pages/{url}",
        :course_id => course_id,
        :url => url)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      Page.new(response)
      
    end
    
    # Delete page
    def delete_page_groups(group_id,url,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "url is required" if url.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :url => url
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/pages/{url}",
        :group_id => group_id,
        :url => url)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      Page.new(response)
      
    end
    
    # List revisions
    def list_revisions_courses(course_id,url,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "url is required" if url.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :url => url
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/pages/{url}/revisions",
        :course_id => course_id,
        :url => url)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, PageRevision, path, query_params)
      
    end
    
    # List revisions
    def list_revisions_groups(group_id,url,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "url is required" if url.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :url => url
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/pages/{url}/revisions",
        :group_id => group_id,
        :url => url)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, PageRevision, path, query_params)
      
    end
    
    # Show revision
    def show_revision_courses_latest(course_id,url,opts={})
      query_param_keys = [
        :summary
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "url is required" if url.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :url => url
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/pages/{url}/revisions/latest",
        :course_id => course_id,
        :url => url)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      PageRevision.new(response)
      
    end
    
    # Show revision
    def show_revision_groups_latest(group_id,url,opts={})
      query_param_keys = [
        :summary
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "url is required" if url.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :url => url
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/pages/{url}/revisions/latest",
        :group_id => group_id,
        :url => url)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      PageRevision.new(response)
      
    end
    
    # Show revision
    def show_revision_courses_revision_id(course_id,url,revision_id,opts={})
      query_param_keys = [
        :summary
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "url is required" if url.nil?
      raise "revision_id is required" if revision_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :url => url,
        :revision_id => revision_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/pages/{url}/revisions/{revision_id}",
        :course_id => course_id,
        :url => url,
        :revision_id => revision_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      PageRevision.new(response)
      
    end
    
    # Show revision
    def show_revision_groups_revision_id(group_id,url,revision_id,opts={})
      query_param_keys = [
        :summary
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "url is required" if url.nil?
      raise "revision_id is required" if revision_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :url => url,
        :revision_id => revision_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/pages/{url}/revisions/{revision_id}",
        :group_id => group_id,
        :url => url,
        :revision_id => revision_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      PageRevision.new(response)
      
    end
    
    # Revert to revision
    def revert_to_revision_courses(course_id,url,revision_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "url is required" if url.nil?
      raise "revision_id is required" if revision_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :url => url,
        :revision_id => revision_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/pages/{url}/revisions/{revision_id}",
        :course_id => course_id,
        :url => url,
        :revision_id => revision_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      PageRevision.new(response)
      
    end
    
    # Revert to revision
    def revert_to_revision_groups(group_id,url,revision_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      raise "url is required" if url.nil?
      raise "revision_id is required" if revision_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id,
        :url => url,
        :revision_id => revision_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/pages/{url}/revisions/{revision_id}",
        :group_id => group_id,
        :url => url,
        :revision_id => revision_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      PageRevision.new(response)
      
    end
    
    # List poll sessions for a poll
    def list_poll_sessions_for_poll(poll_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "poll_id is required" if poll_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :poll_id => poll_id
      )

      # resource path
      path = path_replace("/v1/polls/{poll_id}/poll_sessions",
        :poll_id => poll_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get the results for a single poll session
    def get_results_for_single_poll_session(poll_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "poll_id is required" if poll_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :poll_id => poll_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/polls/{poll_id}/poll_sessions/{id}",
        :poll_id => poll_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Create a single poll session
    def create_single_poll_session(poll_id,poll_sessions__course_id__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :poll_sessions__course_id__,
        :poll_sessions__course_section_id__,
        :poll_sessions__has_public_results__,
        
      ]

      # verify existence of params
      raise "poll_id is required" if poll_id.nil?
      raise "poll_sessions__course_id__ is required" if poll_sessions__course_id__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :poll_id => poll_id,
        :poll_sessions__course_id__ => poll_sessions__course_id__
      )

      # resource path
      path = path_replace("/v1/polls/{poll_id}/poll_sessions",
        :poll_id => poll_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Update a single poll session
    def update_single_poll_session(poll_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :poll_sessions__course_id__,
        :poll_sessions__course_section_id__,
        :poll_sessions__has_public_results__,
        
      ]

      # verify existence of params
      raise "poll_id is required" if poll_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :poll_id => poll_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/polls/{poll_id}/poll_sessions/{id}",
        :poll_id => poll_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Delete a poll session
    def delete_poll_session(poll_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "poll_id is required" if poll_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :poll_id => poll_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/polls/{poll_id}/poll_sessions/{id}",
        :poll_id => poll_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Open a poll session
    def open_poll_session(poll_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "poll_id is required" if poll_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :poll_id => poll_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/polls/{poll_id}/poll_sessions/{id}/open",
        :poll_id => poll_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Close an opened poll session
    def close_opened_poll_session(poll_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "poll_id is required" if poll_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :poll_id => poll_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/polls/{poll_id}/poll_sessions/{id}/close",
        :poll_id => poll_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List opened poll sessions
    def list_opened_poll_sessions(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/poll_sessions/opened",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List closed poll sessions
    def list_closed_poll_sessions(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/poll_sessions/closed",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List poll choices in a poll
    def list_poll_choices_in_poll(poll_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "poll_id is required" if poll_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :poll_id => poll_id
      )

      # resource path
      path = path_replace("/v1/polls/{poll_id}/poll_choices",
        :poll_id => poll_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get a single poll choice
    def get_single_poll_choice(poll_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "poll_id is required" if poll_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :poll_id => poll_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/polls/{poll_id}/poll_choices/{id}",
        :poll_id => poll_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Create a single poll choice
    def create_single_poll_choice(poll_id,poll_choices__text__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :poll_choices__text__,
        :poll_choices__is_correct__,
        :poll_choices__position__,
        
      ]

      # verify existence of params
      raise "poll_id is required" if poll_id.nil?
      raise "poll_choices__text__ is required" if poll_choices__text__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :poll_id => poll_id,
        :poll_choices__text__ => poll_choices__text__
      )

      # resource path
      path = path_replace("/v1/polls/{poll_id}/poll_choices",
        :poll_id => poll_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Update a single poll choice
    def update_single_poll_choice(poll_id,id,poll_choices__text__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :poll_choices__text__,
        :poll_choices__is_correct__,
        :poll_choices__position__,
        
      ]

      # verify existence of params
      raise "poll_id is required" if poll_id.nil?
      raise "id is required" if id.nil?
      raise "poll_choices__text__ is required" if poll_choices__text__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :poll_id => poll_id,
        :id => id,
        :poll_choices__text__ => poll_choices__text__
      )

      # resource path
      path = path_replace("/v1/polls/{poll_id}/poll_choices/{id}",
        :poll_id => poll_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Delete a poll choice
    def delete_poll_choice(poll_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "poll_id is required" if poll_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :poll_id => poll_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/polls/{poll_id}/poll_choices/{id}",
        :poll_id => poll_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Get a single poll submission
    def get_single_poll_submission(poll_id,poll_session_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "poll_id is required" if poll_id.nil?
      raise "poll_session_id is required" if poll_session_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :poll_id => poll_id,
        :poll_session_id => poll_session_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/polls/{poll_id}/poll_sessions/{poll_session_id}/poll_submissions/{id}",
        :poll_id => poll_id,
        :poll_session_id => poll_session_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Create a single poll submission
    def create_single_poll_submission(poll_id,poll_session_id,poll_submissions__poll_choice_id__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :poll_submissions__poll_choice_id__,
        
      ]

      # verify existence of params
      raise "poll_id is required" if poll_id.nil?
      raise "poll_session_id is required" if poll_session_id.nil?
      raise "poll_submissions__poll_choice_id__ is required" if poll_submissions__poll_choice_id__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :poll_id => poll_id,
        :poll_session_id => poll_session_id,
        :poll_submissions__poll_choice_id__ => poll_submissions__poll_choice_id__
      )

      # resource path
      path = path_replace("/v1/polls/{poll_id}/poll_sessions/{poll_session_id}/poll_submissions",
        :poll_id => poll_id,
        :poll_session_id => poll_session_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # List polls
    def list_polls(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/polls",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get a single poll
    def get_single_poll(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/polls/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Create a single poll
    def create_single_poll(polls__question__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :polls__question__,
        :polls__description__,
        
      ]

      # verify existence of params
      raise "polls__question__ is required" if polls__question__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :polls__question__ => polls__question__
      )

      # resource path
      path = path_replace("/v1/polls",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Update a single poll
    def update_single_poll(id,polls__question__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :polls__question__,
        :polls__description__,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "polls__question__ is required" if polls__question__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :polls__question__ => polls__question__
      )

      # resource path
      path = path_replace("/v1/polls/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Delete a poll
    def delete_poll(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/polls/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Query progress
    def query_progress(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/progress/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Progress.new(response)
      
    end
    
    # Retrieve assignment-overridden dates for quizzes
    def retrieve_assignment_overridden_dates_for_quizzes(course_id,opts={})
      query_param_keys = [
        :quiz_assignment_overrides__0____quiz_ids__
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/assignment_overrides",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      QuizAssignmentOverrideSetContainer.new(response)
      
    end
    
    # Set extensions for student quiz submissions
    def set_extensions_for_student_quiz_submissions(course_id,quiz_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :user_id,
        :extra_attempts,
        :extra_time,
        :manually_unlocked,
        :extend_from_now,
        :extend_from_end_at,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/extensions",
        :course_id => course_id,
        :quiz_id => quiz_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Get available quiz IP filters.
    def get_available_quiz_ip_filters(course_id,quiz_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/ip_filters",
        :course_id => course_id,
        :quiz_id => quiz_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Create a question group
    def create_question_group(course_id,quiz_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :quiz_groups__name__,
        :quiz_groups__pick_count__,
        :quiz_groups__question_points__,
        :quiz_groups__assessment_question_bank_id__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/groups",
        :course_id => course_id,
        :quiz_id => quiz_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Update a question group
    def update_question_group(course_id,quiz_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :quiz_groups__name__,
        :quiz_groups__pick_count__,
        :quiz_groups__question_points__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/groups/{id}",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Delete a question group
    def delete_question_group(course_id,quiz_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/groups/{id}",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Reorder question groups
    def reorder_question_groups(course_id,quiz_id,id,order__id__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :order__id__,
        :order__type__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      raise "order__id__ is required" if order__id__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id,
        :order__id__ => order__id__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/groups/{id}/reorder",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # List questions in a quiz or a submission
    def list_questions_in_quiz_or_submission(course_id,quiz_id,opts={})
      query_param_keys = [
        :quiz_submission_id,
        :quiz_submission_attempt
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/questions",
        :course_id => course_id,
        :quiz_id => quiz_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, QuizQuestion, path, query_params)
      
    end
    
    # Get a single quiz question
    def get_single_quiz_question(course_id,quiz_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/questions/{id}",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      QuizQuestion.new(response)
      
    end
    
    # Create a single quiz question
    def create_single_quiz_question(course_id,quiz_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :question__question_name__,
        :question__question_text__,
        :question__quiz_group_id__,
        :question__question_type__,
        :question__position__,
        :question__points_possible__,
        :question__correct_comments__,
        :question__incorrect_comments__,
        :question__neutral_comments__,
        :question__text_after_answers__,
        :question__answers__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/questions",
        :course_id => course_id,
        :quiz_id => quiz_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      QuizQuestion.new(response)
      
    end
    
    # Update an existing quiz question
    def update_existing_quiz_question(course_id,quiz_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :question__question_name__,
        :question__question_text__,
        :question__quiz_group_id__,
        :question__question_type__,
        :question__position__,
        :question__points_possible__,
        :question__correct_comments__,
        :question__incorrect_comments__,
        :question__neutral_comments__,
        :question__text_after_answers__,
        :question__answers__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/questions/{id}",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      QuizQuestion.new(response)
      
    end
    
    # Delete a quiz question
    def delete_quiz_question(course_id,quiz_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/questions/{id}",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Retrieve all quiz reports
    def retrieve_all_quiz_reports(course_id,quiz_id,opts={})
      query_param_keys = [
        :includes_all_versions
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/reports",
        :course_id => course_id,
        :quiz_id => quiz_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection,  QuizReport , path, query_params)
      
    end
    
    # Create a quiz report
    def create_quiz_report(course_id,quiz_id,quiz_report__report_type__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :quiz_report__report_type__,
        :quiz_report__includes_all_versions__,
        :include,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "quiz_report__report_type__ is required" if quiz_report__report_type__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :quiz_report__report_type__ => quiz_report__report_type__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/reports",
        :course_id => course_id,
        :quiz_id => quiz_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      QuizReport.new(response)
      
    end
    
    # Get a quiz report
    def get_quiz_report(course_id,quiz_id,id,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/reports/{id}",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      QuizReport.new(response)
      
    end
    
    # Abort the generation of a report, or remove a previously generated one
    def abort_generation_of_report_or_remove_previously_generated_one(course_id,quiz_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/reports/{id}",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Fetching the latest quiz statistics
    def fetching_latest_quiz_statistics(course_id,quiz_id,opts={})
      query_param_keys = [
        :all_versions
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/statistics",
        :course_id => course_id,
        :quiz_id => quiz_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Submit captured events
    def submit_captured_events(course_id,quiz_id,id,quiz_submission_events,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :quiz_submission_events,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      raise "quiz_submission_events is required" if quiz_submission_events.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id,
        :quiz_submission_events => quiz_submission_events
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/submissions/{id}/events",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Retrieve captured events
    def retrieve_captured_events(course_id,quiz_id,id,opts={})
      query_param_keys = [
        :attempt
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/submissions/{id}/events",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Upload a file
    def upload_file(course_id,quiz_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :name,
        :on_duplicate,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/submissions/self/files",
        :course_id => course_id,
        :quiz_id => quiz_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Get all quiz submission questions.
    def get_all_quiz_submission_questions(quiz_submission_id,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "quiz_submission_id is required" if quiz_submission_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :quiz_submission_id => quiz_submission_id
      )

      # resource path
      path = path_replace("/v1/quiz_submissions/{quiz_submission_id}/questions",
        :quiz_submission_id => quiz_submission_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get a single quiz submission question.
    def get_single_quiz_submission_question(quiz_submission_id,id,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "quiz_submission_id is required" if quiz_submission_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :quiz_submission_id => quiz_submission_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/quiz_submissions/{quiz_submission_id}/questions/{id}",
        :quiz_submission_id => quiz_submission_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Answering questions
    def answering_questions(quiz_submission_id,attempt,validation_token,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :attempt,
        :validation_token,
        :access_code,
        :quiz_questions,
        
      ]

      # verify existence of params
      raise "quiz_submission_id is required" if quiz_submission_id.nil?
      raise "attempt is required" if attempt.nil?
      raise "validation_token is required" if validation_token.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :quiz_submission_id => quiz_submission_id,
        :attempt => attempt,
        :validation_token => validation_token
      )

      # resource path
      path = path_replace("/v1/quiz_submissions/{quiz_submission_id}/questions",
        :quiz_submission_id => quiz_submission_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, QuizSubmissionQuestion, path, query_params)
      
    end
    
    # Flagging a question.
    def flagging_question(quiz_submission_id,id,attempt,validation_token,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :attempt,
        :validation_token,
        :access_code,
        
      ]

      # verify existence of params
      raise "quiz_submission_id is required" if quiz_submission_id.nil?
      raise "id is required" if id.nil?
      raise "attempt is required" if attempt.nil?
      raise "validation_token is required" if validation_token.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :quiz_submission_id => quiz_submission_id,
        :id => id,
        :attempt => attempt,
        :validation_token => validation_token
      )

      # resource path
      path = path_replace("/v1/quiz_submissions/{quiz_submission_id}/questions/{id}/flag",
        :quiz_submission_id => quiz_submission_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Unflagging a question.
    def unflagging_question(quiz_submission_id,id,attempt,validation_token,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :attempt,
        :validation_token,
        :access_code,
        
      ]

      # verify existence of params
      raise "quiz_submission_id is required" if quiz_submission_id.nil?
      raise "id is required" if id.nil?
      raise "attempt is required" if attempt.nil?
      raise "validation_token is required" if validation_token.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :quiz_submission_id => quiz_submission_id,
        :id => id,
        :attempt => attempt,
        :validation_token => validation_token
      )

      # resource path
      path = path_replace("/v1/quiz_submissions/{quiz_submission_id}/questions/{id}/unflag",
        :quiz_submission_id => quiz_submission_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Send a message to unsubmitted or submitted users for the quiz
    def send_message_to_unsubmitted_or_submitted_users_for_quiz(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{id}/submission_users/message",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Get all quiz submissions.
    def get_all_quiz_submissions(course_id,quiz_id,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/submissions",
        :course_id => course_id,
        :quiz_id => quiz_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get a single quiz submission.
    def get_single_quiz_submission(course_id,quiz_id,id,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/submissions/{id}",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Create the quiz submission (start a quiz-taking session)
    def create_quiz_submission_start_quiz_taking_session(course_id,quiz_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :access_code,
        :preview,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/submissions",
        :course_id => course_id,
        :quiz_id => quiz_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Update student question scores and comments.
    def update_student_question_scores_and_comments(course_id,quiz_id,id,attempt,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :attempt,
        :fudge_points,
        :questions,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      raise "attempt is required" if attempt.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id,
        :attempt => attempt
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/submissions/{id}",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Complete the quiz submission (turn it in).
    def complete_quiz_submission_turn_it_in(course_id,quiz_id,id,attempt,validation_token,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :attempt,
        :validation_token,
        :access_code,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz_id is required" if quiz_id.nil?
      raise "id is required" if id.nil?
      raise "attempt is required" if attempt.nil?
      raise "validation_token is required" if validation_token.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id,
        :attempt => attempt,
        :validation_token => validation_token
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{quiz_id}/submissions/{id}/complete",
        :course_id => course_id,
        :quiz_id => quiz_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # List quizzes in a course
    def list_quizzes_in_course(course_id,opts={})
      query_param_keys = [
        :search_term
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Quiz, path, query_params)
      
    end
    
    # Get a single quiz
    def get_single_quiz(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Quiz.new(response)
      
    end
    
    # Create a quiz
    def create_quiz(course_id,quiz__title__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :quiz__title__,
        :quiz__description__,
        :quiz__quiz_type__,
        :quiz__assignment_group_id__,
        :quiz__time_limit__,
        :quiz__shuffle_answers__,
        :quiz__hide_results__,
        :quiz__show_correct_answers__,
        :quiz__show_correct_answers_last_attempt__,
        :quiz__show_correct_answers_at__,
        :quiz__hide_correct_answers_at__,
        :quiz__allowed_attempts__,
        :quiz__scoring_policy__,
        :quiz__one_question_at_a_time__,
        :quiz__cant_go_back__,
        :quiz__access_code__,
        :quiz__ip_filter__,
        :quiz__due_at__,
        :quiz__lock_at__,
        :quiz__unlock_at__,
        :quiz__published__,
        :quiz__one_time_results__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "quiz__title__ is required" if quiz__title__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :quiz__title__ => quiz__title__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Quiz.new(response)
      
    end
    
    # Edit a quiz
    def edit_quiz(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :quiz__notify_of_update__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      Quiz.new(response)
      
    end
    
    # Delete a quiz
    def delete_quiz(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      Quiz.new(response)
      
    end
    
    # Reorder quiz items
    def reorder_quiz_items(course_id,id,order__id__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :order__id__,
        :order__type__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      raise "order__id__ is required" if order__id__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id,
        :order__id__ => order__id__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/quizzes/{id}/reorder",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # List roles
    def list_roles(account_id,opts={})
      query_param_keys = [
        :state,
        :show_inherited
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/roles",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Role, path, query_params)
      
    end
    
    # Get a single role
    def get_single_role(id,account_id,role_id,opts={})
      query_param_keys = [
        :role_id,
        :role
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "account_id is required" if account_id.nil?
      raise "role_id is required" if role_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :account_id => account_id,
        :role_id => role_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/roles/{id}",
        :id => id,
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Role.new(response)
      
    end
    
    # Create a new role
    def create_new_role(account_id,label,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :label,
        :role,
        :base_role_type,
        :permissions____x_____explicit__,
        :permissions____x_____enabled__,
        :permissions____x_____locked__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "label is required" if label.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :label => label
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/roles",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Role.new(response)
      
    end
    
    # Deactivate a role
    def deactivate_role(account_id,id,role_id,opts={})
      query_param_keys = [
        :role_id,
        :role
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      raise "role_id is required" if role_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id,
        :role_id => role_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/roles/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      Role.new(response)
      
    end
    
    # Activate a role
    def activate_role(account_id,id,role_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :role_id,
        :role,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      raise "role_id is required" if role_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id,
        :role_id => role_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/roles/{id}/activate",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Role.new(response)
      
    end
    
    # Update a role
    def update_role(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :label,
        :permissions____x_____explicit__,
        :permissions____x_____enabled__,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/roles/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      Role.new(response)
      
    end
    
    # Get SIS import list
    def get_sis_import_list(account_id,opts={})
      query_param_keys = [
        :created_since
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/sis_imports",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, SisImport, path, query_params)
      
    end
    
    # Import SIS data
    def import_sis_data(account_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :import_type,
        :attachment,
        :extension,
        :batch_mode,
        :batch_mode_term_id,
        :override_sis_stickiness,
        :add_sis_stickiness,
        :clear_sis_stickiness,
        :diffing_data_set_identifier,
        :diffing_remaster_data_set,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/sis_imports",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      SisImport.new(response)
      
    end
    
    # Get SIS import status
    def get_sis_import_status(account_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/sis_imports/{id}",
        :account_id => account_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      SisImport.new(response)
      
    end
    
    # Find recipients
    def find_recipients_conversations(opts={})
      query_param_keys = [
        :search,
        :context,
        :exclude,
        :type,
        :user_id,
        :from_conversation_id,
        :permissions
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/conversations/find_recipients",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Find recipients
    def find_recipients_search(opts={})
      query_param_keys = [
        :search,
        :context,
        :exclude,
        :type,
        :user_id,
        :from_conversation_id,
        :permissions
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/search/recipients",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List all courses
    def list_all_courses(opts={})
      query_param_keys = [
        :search,
        :public_only,
        :open_enrollment_only
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/search/all_courses",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List course sections
    def list_course_sections(course_id,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/sections",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Section, path, query_params)
      
    end
    
    # Create course section
    def create_course_section(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :course_section__name__,
        :course_section__sis_section_id__,
        :course_section__start_at__,
        :course_section__end_at__,
        :course_section__restrict_enrollments_to_section_dates__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/sections",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Section.new(response)
      
    end
    
    # Cross-list a Section
    def cross_list_section(id,new_course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "new_course_id is required" if new_course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :new_course_id => new_course_id
      )

      # resource path
      path = path_replace("/v1/sections/{id}/crosslist/{new_course_id}",
        :id => id,
        :new_course_id => new_course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Section.new(response)
      
    end
    
    # De-cross-list a Section
    def de_cross_list_section(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/sections/{id}/crosslist",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      Section.new(response)
      
    end
    
    # Edit a section
    def edit_section(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/sections/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      Section.new(response)
      
    end
    
    # Get section information
    def get_section_information_courses(course_id,id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :id => id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/sections/{id}",
        :course_id => course_id,
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Section.new(response)
      
    end
    
    # Get section information
    def get_section_information_sections(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/sections/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Section.new(response)
      
    end
    
    # Delete a section
    def delete_section(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/sections/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      Section.new(response)
      
    end
    
    # Get Kaltura config
    def get_kaltura_config(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/services/kaltura",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Start Kaltura session
    def start_kaltura_session(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/services/kaltura_session",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Upload a file
    def upload_file(course_id,assignment_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}/comments/files",
        :course_id => course_id,
        :assignment_id => assignment_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Submit an assignment
    def submit_assignment_courses(course_id,assignment_id,submission__submission_type__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :comment__text_comment__,
        :submission__submission_type__,
        :submission__body__,
        :submission__url__,
        :submission__file_ids__,
        :submission__media_comment_id__,
        :submission__media_comment_type__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "submission__submission_type__ is required" if submission__submission_type__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id,
        :submission__submission_type__ => submission__submission_type__
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/submissions",
        :course_id => course_id,
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Submit an assignment
    def submit_assignment_sections(section_id,assignment_id,submission__submission_type__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :comment__text_comment__,
        :submission__submission_type__,
        :submission__body__,
        :submission__url__,
        :submission__file_ids__,
        :submission__media_comment_id__,
        :submission__media_comment_type__,
        
      ]

      # verify existence of params
      raise "section_id is required" if section_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "submission__submission_type__ is required" if submission__submission_type__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :section_id => section_id,
        :assignment_id => assignment_id,
        :submission__submission_type__ => submission__submission_type__
      )

      # resource path
      path = path_replace("/v1/sections/{section_id}/assignments/{assignment_id}/submissions",
        :section_id => section_id,
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # List assignment submissions
    def list_assignment_submissions_courses(course_id,assignment_id,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/submissions",
        :course_id => course_id,
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Submission, path, query_params)
      
    end
    
    # List assignment submissions
    def list_assignment_submissions_sections(section_id,assignment_id,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "section_id is required" if section_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :section_id => section_id,
        :assignment_id => assignment_id
      )

      # resource path
      path = path_replace("/v1/sections/{section_id}/assignments/{assignment_id}/submissions",
        :section_id => section_id,
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Submission, path, query_params)
      
    end
    
    # List submissions for multiple assignments
    def list_submissions_for_multiple_assignments_courses(course_id,opts={})
      query_param_keys = [
        :student_ids,
        :assignment_ids,
        :grouped,
        :grading_period_id,
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/students/submissions",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List submissions for multiple assignments
    def list_submissions_for_multiple_assignments_sections(section_id,opts={})
      query_param_keys = [
        :student_ids,
        :assignment_ids,
        :grouped,
        :grading_period_id,
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "section_id is required" if section_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :section_id => section_id
      )

      # resource path
      path = path_replace("/v1/sections/{section_id}/students/submissions",
        :section_id => section_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get a single submission
    def get_single_submission_courses(course_id,assignment_id,user_id,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}",
        :course_id => course_id,
        :assignment_id => assignment_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Get a single submission
    def get_single_submission_sections(section_id,assignment_id,user_id,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "section_id is required" if section_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :section_id => section_id,
        :assignment_id => assignment_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}",
        :section_id => section_id,
        :assignment_id => assignment_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Upload a file
    def upload_file_courses(course_id,assignment_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}/files",
        :course_id => course_id,
        :assignment_id => assignment_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Upload a file
    def upload_file_sections(section_id,assignment_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "section_id is required" if section_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :section_id => section_id,
        :assignment_id => assignment_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}/files",
        :section_id => section_id,
        :assignment_id => assignment_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Grade or comment on a submission
    def grade_or_comment_on_submission_courses(course_id,assignment_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :comment__text_comment__,
        :comment__group_comment__,
        :comment__media_comment_id__,
        :comment__media_comment_type__,
        :comment__file_ids__,
        :include__visibility__,
        :submission__posted_grade__,
        :rubric_assessment,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}",
        :course_id => course_id,
        :assignment_id => assignment_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Grade or comment on a submission
    def grade_or_comment_on_submission_sections(section_id,assignment_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :comment__text_comment__,
        :comment__group_comment__,
        :comment__media_comment_id__,
        :comment__media_comment_type__,
        :comment__file_ids__,
        :include__visibility__,
        :submission__posted_grade__,
        :rubric_assessment,
        
      ]

      # verify existence of params
      raise "section_id is required" if section_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :section_id => section_id,
        :assignment_id => assignment_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}",
        :section_id => section_id,
        :assignment_id => assignment_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Grade or comment on multiple submissions
    def grade_or_comment_on_multiple_submissions_courses_submissions(course_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :grade_data___student_id_____posted_grade__,
        :grade_data___student_id_____rubric_assessment__,
        :grade_data___student_id_____text_comment__,
        :grade_data___student_id_____group_comment__,
        :grade_data___student_id_____media_comment_id__,
        :grade_data___student_id_____media_comment_type__,
        :grade_data___student_id_____file_ids__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/submissions/update_grades",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Progress.new(response)
      
    end
    
    # Grade or comment on multiple submissions
    def grade_or_comment_on_multiple_submissions_courses_assignments(course_id,assignment_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :grade_data___student_id_____posted_grade__,
        :grade_data___student_id_____rubric_assessment__,
        :grade_data___student_id_____text_comment__,
        :grade_data___student_id_____group_comment__,
        :grade_data___student_id_____media_comment_id__,
        :grade_data___student_id_____media_comment_type__,
        :grade_data___student_id_____file_ids__,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/submissions/update_grades",
        :course_id => course_id,
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Progress.new(response)
      
    end
    
    # Grade or comment on multiple submissions
    def grade_or_comment_on_multiple_submissions_sections_submissions(section_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :grade_data___student_id_____posted_grade__,
        :grade_data___student_id_____rubric_assessment__,
        :grade_data___student_id_____text_comment__,
        :grade_data___student_id_____group_comment__,
        :grade_data___student_id_____media_comment_id__,
        :grade_data___student_id_____media_comment_type__,
        :grade_data___student_id_____file_ids__,
        
      ]

      # verify existence of params
      raise "section_id is required" if section_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :section_id => section_id
      )

      # resource path
      path = path_replace("/v1/sections/{section_id}/submissions/update_grades",
        :section_id => section_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Progress.new(response)
      
    end
    
    # Grade or comment on multiple submissions
    def grade_or_comment_on_multiple_submissions_sections_assignments(section_id,assignment_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :grade_data___student_id_____posted_grade__,
        :grade_data___student_id_____rubric_assessment__,
        :grade_data___student_id_____text_comment__,
        :grade_data___student_id_____group_comment__,
        :grade_data___student_id_____media_comment_id__,
        :grade_data___student_id_____media_comment_type__,
        :grade_data___student_id_____file_ids__,
        
      ]

      # verify existence of params
      raise "section_id is required" if section_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :section_id => section_id,
        :assignment_id => assignment_id
      )

      # resource path
      path = path_replace("/v1/sections/{section_id}/assignments/{assignment_id}/submissions/update_grades",
        :section_id => section_id,
        :assignment_id => assignment_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      Progress.new(response)
      
    end
    
    # Mark submission as read
    def mark_submission_as_read_courses(course_id,assignment_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}/read",
        :course_id => course_id,
        :assignment_id => assignment_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Mark submission as read
    def mark_submission_as_read_sections(section_id,assignment_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "section_id is required" if section_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :section_id => section_id,
        :assignment_id => assignment_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}/read",
        :section_id => section_id,
        :assignment_id => assignment_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Mark submission as unread
    def mark_submission_as_unread_courses(course_id,assignment_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :assignment_id => assignment_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/assignments/{assignment_id}/submissions/{user_id}/read",
        :course_id => course_id,
        :assignment_id => assignment_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Mark submission as unread
    def mark_submission_as_unread_sections(section_id,assignment_id,user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "section_id is required" if section_id.nil?
      raise "assignment_id is required" if assignment_id.nil?
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :section_id => section_id,
        :assignment_id => assignment_id,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/sections/{section_id}/assignments/{assignment_id}/submissions/{user_id}/read",
        :section_id => section_id,
        :assignment_id => assignment_id,
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # List available tabs for a course or group
    def list_available_tabs_for_course_or_group_courses(course_id,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/tabs",
        :course_id => course_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List available tabs for a course or group
    def list_available_tabs_for_course_or_group_groups(group_id,opts={})
      query_param_keys = [
        :include
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "group_id is required" if group_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :group_id => group_id
      )

      # resource path
      path = path_replace("/v1/groups/{group_id}/tabs",
        :group_id => group_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Update a tab for a course
    def update_tab_for_course(course_id,tab_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :position,
        :hidden,
        
      ]

      # verify existence of params
      raise "course_id is required" if course_id.nil?
      raise "tab_id is required" if tab_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :course_id => course_id,
        :tab_id => tab_id
      )

      # resource path
      path = path_replace("/v1/courses/{course_id}/tabs/{tab_id}",
        :course_id => course_id,
        :tab_id => tab_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      Tab.new(response)
      
    end
    
    # List observees
    def list_observees(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/observees",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, User, path, query_params)
      
    end
    
    # Add an observee with credentials
    def add_observee_with_credentials(user_id,observee__unique_id__,observee__password__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :observee__unique_id__,
        :observee__password__,
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "observee__unique_id__ is required" if observee__unique_id__.nil?
      raise "observee__password__ is required" if observee__password__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :observee__unique_id__ => observee__unique_id__,
        :observee__password__ => observee__password__
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/observees",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      User.new(response)
      
    end
    
    # Show an observee
    def show_observee(user_id,observee_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "observee_id is required" if observee_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :observee_id => observee_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/observees/{observee_id}",
        :user_id => user_id,
        :observee_id => observee_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      User.new(response)
      
    end
    
    # Add an observee
    def add_observee(user_id,observee_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "observee_id is required" if observee_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :observee_id => observee_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/observees/{observee_id}",
        :user_id => user_id,
        :observee_id => observee_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      User.new(response)
      
    end
    
    # Remove an observee
    def remove_observee(user_id,observee_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "observee_id is required" if observee_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :observee_id => observee_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/observees/{observee_id}",
        :user_id => user_id,
        :observee_id => observee_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      User.new(response)
      
    end
    
    # List users in account
    def list_users_in_account(account_id,opts={})
      query_param_keys = [
        :search_term
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/users",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, User, path, query_params)
      
    end
    
    # List the activity stream
    def list_activity_stream_self(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/users/self/activity_stream",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List the activity stream
    def list_activity_stream_activity_stream(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/users/activity_stream",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Activity stream summary
    def activity_stream_summary(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/users/self/activity_stream/summary",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List the TODO items
    def list_todo_items(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/users/self/todo",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # List upcoming assignments, calendar events
    def list_upcoming_assignments_calendar_events(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/users/self/upcoming_events",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Hide a stream item
    def hide_stream_item(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/users/self/activity_stream/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Hide all stream items
    def hide_all_stream_items(opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # set default values and merge with input
      options = underscored_merge_opts(opts,
        {}
      
      )

      # resource path
      path = path_replace("/v1/users/self/activity_stream",
        )
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
    # Upload a file
    def upload_file(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/files",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      response
      
    end
    
    # Show user details
    def show_user_details(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/users/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      User.new(response)
      
    end
    
    # Create a user
    def create_user(account_id,pseudonym__unique_id__,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :user__name__,
        :user__short_name__,
        :user__sortable_name__,
        :user__time_zone__,
        :user__locale__,
        :user__birthdate__,
        :user__terms_of_use__,
        :pseudonym__unique_id__,
        :pseudonym__password__,
        :pseudonym__sis_user_id__,
        :pseudonym__send_confirmation__,
        :communication_channel__type__,
        :communication_channel__address__,
        :communication_channel__confirmation_url__,
        :communication_channel__skip_confirmation__,
        :force_validations,
        
      ]

      # verify existence of params
      raise "account_id is required" if account_id.nil?
      raise "pseudonym__unique_id__ is required" if pseudonym__unique_id__.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :account_id => account_id,
        :pseudonym__unique_id__ => pseudonym__unique_id__
      )

      # resource path
      path = path_replace("/v1/accounts/{account_id}/users",
        :account_id => account_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:post, path, query_params, form_params, headers)
      User.new(response)
      
    end
    
    # Update user settings.
    def update_user_settings(id,opts={})
      query_param_keys = [
        :manual_mark_as_read
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/users/{id}/settings",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Edit a user
    def edit_user(id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :user__name__,
        :user__short_name__,
        :user__sortable_name__,
        :user__time_zone__,
        :user__locale__,
        :user__avatar____token__,
        :user__avatar____url__,
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id
      )

      # resource path
      path = path_replace("/v1/users/{id}",
        :id => id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      User.new(response)
      
    end
    
    # Merge user into another user
    def merge_user_into_another_user_destination_user_id(id,destination_user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "destination_user_id is required" if destination_user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :destination_user_id => destination_user_id
      )

      # resource path
      path = path_replace("/v1/users/{id}/merge_into/{destination_user_id}",
        :id => id,
        :destination_user_id => destination_user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      User.new(response)
      
    end
    
    # Merge user into another user
    def merge_user_into_another_user_accounts(id,destination_account_id,destination_user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "id is required" if id.nil?
      raise "destination_account_id is required" if destination_account_id.nil?
      raise "destination_user_id is required" if destination_user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :id => id,
        :destination_account_id => destination_account_id,
        :destination_user_id => destination_user_id
      )

      # resource path
      path = path_replace("/v1/users/{id}/merge_into/accounts/{destination_account_id}/users/{destination_user_id}",
        :id => id,
        :destination_account_id => destination_account_id,
        :destination_user_id => destination_user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      User.new(response)
      
    end
    
    # Get user profile
    def get_user_profile(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/profile",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      Profile.new(response)
      
    end
    
    # List avatar options
    def list_avatar_options(user_id,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/avatars",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, Avatar, path, query_params)
      
    end
    
    # List user page views
    def list_user_page_views(user_id,opts={})
      query_param_keys = [
        :start_time,
        :end_time
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/page_views",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      RemoteCollection.new(connection, PageView, path, query_params)
      
    end
    
    # Store custom data
    def store_custom_data(user_id,ns,data,opts={})
      query_param_keys = [
        
      ]

      form_param_keys = [
        :ns,
        :data,
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "ns is required" if ns.nil?
      raise "data is required" if data.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :ns => ns,
        :data => data
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/custom_data",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:put, path, query_params, form_params, headers)
      response
      
    end
    
    # Load custom data
    def load_custom_data(user_id,ns,opts={})
      query_param_keys = [
        :ns
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "ns is required" if ns.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :ns => ns
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/custom_data",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:get, path, query_params, form_params, headers)
      response
      
    end
    
    # Delete custom data
    def delete_custom_data(user_id,ns,opts={})
      query_param_keys = [
        :ns
      ]

      form_param_keys = [
        
      ]

      # verify existence of params
      raise "user_id is required" if user_id.nil?
      raise "ns is required" if ns.nil?
      # set default values and merge with input
      options = underscored_merge_opts(opts,
        :user_id => user_id,
        :ns => ns
      )

      # resource path
      path = path_replace("/v1/users/{user_id}/custom_data",
        :user_id => user_id)
      headers = nil
      form_params = select_params(options, form_param_keys)
      query_params = select_query_params(options, query_param_keys)

      response = mixed_request(:delete, path, query_params, form_params, headers)
      response
      
    end
    
  end
end

